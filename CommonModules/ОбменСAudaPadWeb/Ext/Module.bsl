
#Область ПрограммныйИнтерфейс

// Отправляет запрос на создание дела по заказ-наряду
//
// Параметры:
//  ЗаказНаряд           - ДокументСсылка.ЗаказНаряд - Документ для которого создается дело;
//  ПараметрыПодключения - Структура                 - Параметры подключения к серверу;
//  ИдентификаторДела    - УникальныйИдентификатор   - Идентификатор вновь созданного дела;
//  ИдентификаторЗадания - УникальныйИдентификатор   - Идентификатор вновь созданного задания.
// 
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//    * Успех     - Булево - Результат создания задания
//    * Сообщение - Строка - Сообщение пользователю. 
Функция СоздатьЗадание(ЗаказНаряд, ПараметрыПодключения, ИдентификаторДела, ИдентификаторЗадания) Экспорт
	
	WSПроксиЗаданий = НовыйWSПроксиЗаданий(ПараметрыПодключения);
	
	ПараметрыЗапроса = Новый Структура();
	ПараметрыЗапроса.Вставить("loginId", ПараметрыПодключения.Логин);
	ПараметрыЗапроса.Вставить("password", ПараметрыПодключения.Пароль);
	ПараметрыЗапроса.Вставить("markForDownload", "true");
	
	Payload = ОбменСAudaPadWebЗащищенныеФункцииСервер.ПолучитьТекстНовогоЗадания(ЗаказНаряд);
	Результат = Новый Структура("Успех,Сообщение", Истина, "");
	
	Если
		НЕ WSПроксиЗаданий.ВыполнитьЗапрос("createTask", ПараметрыЗапроса, Payload)
		ИЛИ WSПроксиЗаданий.ОтветСервераОбъект.Body.Свойства().Получить("createTaskResponse") = Неопределено
	Тогда
		
		Возврат Результат;
		
	КонецЕсли;
	
	Если WSПроксиЗаданий.ОтветСервераОбъект.Body.createTaskResponse.returnCode = "0" Тогда
		
		ИдентификаторДела = Новый УникальныйИдентификатор(
			WSПроксиЗаданий.ОтветСервераОбъект.Body.createTaskResponse.message.caseId);
		ИдентификаторЗадания = Новый УникальныйИдентификатор(
			WSПроксиЗаданий.ОтветСервераОбъект.Body.createTaskResponse.message.taskId);
		Возврат Результат;
		
	КонецЕсли;
	
	Результат.Успех = Ложь;
	Результат.Сообщение = ДайТекстСообщенияОбОшибке(WSПроксиЗаданий.ОтветСервераОбъект.Body.createTaskResponse);
	Возврат Результат;
	
КонецФункции

// Отправляет запрос на Закрытие дела по заказ-наряду
//
// Параметры:
//  ИдентификаторЗадания - УникальныйИдентификатор	 - Идентификатор вновь созданного задания
//  ПараметрыПодключения - Структура - Параметры подключения к серверу
//
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//  	* Успех 	- Булево - Результат создания задания
//      * Сообщение - Строка - Сообщение пользователю 
//
Функция ЗакрытьЗадание(ИдентификаторЗадания, ПараметрыПодключения) Экспорт
	
	WSПроксиЗаданий = НовыйWSПроксиЗаданий(ПараметрыПодключения);	
	
	ПараметрыЗапроса = Новый Структура();
	ПараметрыЗапроса.Вставить("loginId"  , ПараметрыПодключения.Логин);
	ПараметрыЗапроса.Вставить("password" , ПараметрыПодключения.Пароль);
	ПараметрыЗапроса.Вставить("taskId"   , ВРег(Строка(ИдентификаторЗадания)));
	
	Результат = Новый Структура("Успех,Сообщение", Истина, "");
	
	Если
		НЕ WSПроксиЗаданий.ВыполнитьЗапрос("closeTask", ПараметрыЗапроса)
		ИЛИ WSПроксиЗаданий.ОтветСервераОбъект.Body.Свойства().Получить("closeTaskResponse") = Неопределено
		ИЛИ WSПроксиЗаданий.ОтветСервераОбъект.Body.closeTaskResponse.returnCode = "0"
	Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат.Успех = Ложь;
	Результат.Сообщение = ДайТекстСообщенияОбОшибке(WSПроксиЗаданий.ОтветСервераОбъект.Body.closeTaskResponse);
	Возврат Результат;
	
КонецФункции

// Отправляет запрос на получение списка дел
//
// Параметры:
//  ПараметрыПодключения - Структура - Параметры подключения к серверу
//  Фильтры				 - Структура - Фильтры заданий
//  СписокЗаданийPayLoad - Строка	 - Результат с сервера.
// 
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//  	* Успех 	- Булево - Результат создания задания
//      * Сообщение - Строка - Сообщение пользователю. 
//
Функция ЗагрузитьСписокЗаданий(ПараметрыПодключения, Фильтры, СписокЗаданийPayLoad) Экспорт
	
	WSПроксиЗаданий = НовыйWSПроксиЗаданий(ПараметрыПодключения);
	Результат = Новый Структура("Успех,Сообщение", Истина, "");
	
	ПараметрыЗапроса = Новый Структура();
	ПараметрыЗапроса.Вставить("loginId"        , ПараметрыПодключения.Логин);
	ПараметрыЗапроса.Вставить("password"       , ПараметрыПодключения.Пароль);
	ПараметрыЗапроса.Вставить("fromDate"       , Формат(Фильтры.НачалоПериодаФильтр, "ДФ=""гггг-ММ-дд"""));
	ПараметрыЗапроса.Вставить("toDate"         , Формат(Фильтры.ОкончаниеПериодаФильтр, "ДФ=""гггг-ММ-дд"""));
	ПараметрыЗапроса.Вставить("box"            , Фильтры.СтатусЗадания);
	ПараметрыЗапроса.Вставить("fieldsToReturn" , ПоляСпискаКалькуляций());
	
	Если
		НЕ WSПроксиЗаданий.ВыполнитьЗапрос("getTaskList", ПараметрыЗапроса)
		ИЛИ WSПроксиЗаданий.ОтветСервераОбъект.Body.Свойства().Получить("getTaskListResponse") = Неопределено
	Тогда
	
		Возврат Результат;
		
	КонецЕсли;
	
	Если WSПроксиЗаданий.ОтветСервераОбъект.Body.getTaskListResponse.returnCode = "0" Тогда
		
		СписокЗаданийPayLoad = WSПроксиЗаданий.ОтветСервераОбъект.Body.getTaskListResponse.payload;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат.Успех = Ложь;
	Результат.Сообщение = ДайТекстСообщенияОбОшибке(WSПроксиЗаданий.ОтветСервераОбъект.Body.getTaskListResponse);
	Возврат Результат;
	
КонецФункции

// Получить информацию о деле
//
// Параметры:
//  ИдентификаторЗадания - УникальныйИдентификатор	 - Идентификатор созданного задания
//  ПараметрыПодключения - Структура				 - Параметры подключения к серверу
//  СодержаниеЗадания	 - 							 - Содержит описание задания
// 
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//  * Успех 	- Булево - Результат создания задания
//  * Сообщение - Строка - Сообщение пользователю
//
Функция ЗагрузитьЗадание(Знач ИдентификаторЗадания, ПараметрыПодключения, СодержаниеЗадания) Экспорт
	
	WSПроксиЗаданий = НовыйWSПроксиЗаданий(ПараметрыПодключения);
	
	ПараметрыЗапроса = Новый Структура();
	ПараметрыЗапроса.Вставить("loginId"  , ПараметрыПодключения.Логин);
	ПараметрыЗапроса.Вставить("password" , ПараметрыПодключения.Пароль);
	ПараметрыЗапроса.Вставить("taskId"   , ИдентификаторЗадания);
	
	Результат = Новый Структура("Успех,Сообщение", Истина, "");
	
	Если
		НЕ WSПроксиЗаданий.ВыполнитьЗапрос("getTask", ПараметрыЗапроса)
		ИЛИ WSПроксиЗаданий.ОтветСервераОбъект.Body.Свойства().Получить("getTaskResponse") = Неопределено
	Тогда
	
		Результат.Успех = Ложь;
		Результат.Сообщение = WSПроксиЗаданий.СообщениеОбОшибке;
		Возврат Результат;
		
	КонецЕсли;
	
	Если WSПроксиЗаданий.ОтветСервераОбъект.Body.getTaskResponse.returnCode = "0" Тогда
		
		СодержаниеЗадания = WSПроксиЗаданий.ОтветСервераОбъект.Body.getTaskResponse.payload;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат.Успех = Ложь;
	Результат.Сообщение = ДайТекстСообщенияОбОшибке(WSПроксиЗаданий.ОтветСервераОбъект.Body.getTaskResponse);
	Возврат Результат;
	
КонецФункции

// Отправляет запрос на прикрепление файла
//
// Параметры:
//  ОписаниеФайла		 - Строка					 - Строка BASE64 в обертке
//  ИдентификаторЗадания - УникальныйИдентификатор	 - Идентификатор вновь созданного задания
//  ПараметрыПодключения - Структура				 - Параметры подключения к серверу.
// 
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//  	* Успех 	- Булево - Результат создания задания
//      * Сообщение - Строка - Сообщение пользователю. 
//
Функция ПрикрепитьФайл(ОписаниеФайла, ИдентификаторЗадания, ПараметрыПодключения) Экспорт
	WSПроксиЗаданий = Неопределено;
	
	Результат = WSПроксиПрикреплений(ПараметрыПодключения, WSПроксиЗаданий);
	Если НЕ Результат.Успех Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат = Новый Структура("Успех,Сообщение", Истина, "");
	
	WSПроксиЗаданий.УстановитьЗаголовкиПоУмолчанию();
	
	// завернем параметры для передачи
	ПараметрыЗапроса = Новый Структура();
	ПараметрыЗапроса.Вставить("loginId"  , ПараметрыПодключения.Логин);
	ПараметрыЗапроса.Вставить("password" , ПараметрыПодключения.Пароль);
	ПараметрыЗапроса.Вставить("taskId"   , ВРег(Строка(ИдентификаторЗадания)));
	
	Если WSПроксиЗаданий.ВыполнитьЗапрос("addAttachmentsToTask", ПараметрыЗапроса, ОписаниеФайла) Тогда
		Если WSПроксиЗаданий.ОтветСервераОбъект.Body.Свойства().Получить("addAttachmentsToTaskResponse") <> Неопределено И
			WSПроксиЗаданий.ОтветСервераОбъект.Body.addAttachmentsToTaskResponse.returnCode <> "0" Тогда
			
			Результат.Успех = Ложь;
			
			Если ТипЗнч(WSПроксиЗаданий.ОтветСервераОбъект.Body.addAttachmentsToTaskResponse.message) = Тип("ОбъектXDTO") Тогда
				Результат.Сообщение = WSПроксиЗаданий.ОтветСервераОбъект.Body.addAttachmentsToTaskResponse.message.text;
			ИначеЕсли ТипЗнч(WSПроксиЗаданий.ОтветСервераОбъект.Body.addAttachmentsToTaskResponse.message) = Тип("СписокXDTO") Тогда
				Для Каждого Сообщение Из WSПроксиЗаданий.ОтветСервераОбъект.Body.addAttachmentsToTaskResponse.message Цикл
					Результат.Сообщение = Результат.Сообщение + ?(ПустаяСтрока(Результат.Сообщение), "", Символы.ПС) + Сообщение.text;
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Выполняет расчет хэша
//
// Параметры:
//  Текст	 - Строка - Строка для составления ХЕШ функции
// 
// Возвращаемое значение:
//   Строка - Значение ХЕШ функции, без пробелов 
//
Функция СформироватьХешСтроки(Текст) Экспорт
	
	Хеш = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеш.Добавить(Текст);       
	
	Возврат СтрЗаменить(Строка(Хеш.ХешСумма), " ", "");
	
КонецФункции

Процедура ЗаполнитьТипДелаВидамРемонта() Экспорт
	
	Если Не ДоступенОбменСAudaPadWeb() Тогда
		Возврат;
	КонецЕсли;
	
	ТипДела = ТипДелаВAudaPadWebПоУмолчанию();
	
	УстановитьПривилегированныйРежим(Истина);
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	ВидыРемонта.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ВидыРемонта КАК ВидыРемонта
	|ГДЕ
	|	ВидыРемонта.ТипДелаВAudaPadWeb = ЗНАЧЕНИЕ(Перечисление.ТипыДелВAudaPadWeb.ПустаяСсылка)";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		ВидРемонта = Выборка.Ссылка.ПолучитьОбъект();
		ВидРемонта.ТипДелаВAudaPadWeb = ТипДела;
		ВидРемонта.ОбменДанными.Загрузка = Истина;
		
		Попытка
			ВидРемонта.Записать();
		Исключение
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

// Для заполнения типа дела в AudaPad Web по умолчанию
// 
// Возвращаемое значение:
//  ПеречисленияСсылка.ТипыДелВAudaPadWeb - Тип дела.
//
Функция ТипДелаВAudaPadWebПоУмолчанию() Экспорт
	
	Возврат Перечисления.ТипыДелВAudaPadWeb.СлесарныйРемонт;
	
КонецФункции // ТипДелаВAudaPadWebПоУмолчанию()

// Процедура - Заполнить табличные части документа
//
// Параметры:
//  Параметры		 - Структура - Параметры заполнения
//  Форма			 - Форма	 - Используемая форма
//  ВсегоПоДокументу - Число	 - Сумма по документу.
//
Процедура ЗаполнитьТабличныеЧастиДокумента(Параметры, Форма, ВсегоПоДокументу = Неопределено) Экспорт
	КурсКалькуляции                  = Неопределено;
	ВалютаРасчета                    = Неопределено;
	РПВЧас                           = Неопределено;
	НормочасОкраски                  = Неопределено;
	СтоимостьОдногоРП                = 0;
	ИдентификаторПричиныОбращения    = "";
	ДополнительныеПараметрыДокументов = Неопределено;
	Объект                           = Неопределено;
	ЗаказНарядОбъект                 = Неопределено;
	ТаблицаСоответствияАвторабот     = Неопределено;
	ТаблицаСоответствияТоваров       = Неопределено;
	ДополнительныеКоды               = Неопределено;
	ЗаявкаНаРемонтОбъект             = Неопределено;
	ИтогоПоДокументу                 = Неопределено;
	
	Параметры.Свойство("ДополнительныеПараметрыДокументов", ДополнительныеПараметрыДокументов);
	Параметры.Свойство("Объект"                          , Объект);
	Параметры.Свойство("ЗаказНарядОбъект"                , ЗаказНарядОбъект);
	Параметры.Свойство("ТаблицаСоответствияАвторабот"    , ТаблицаСоответствияАвторабот);
	Параметры.Свойство("ТаблицаСоответствияТоваров"      , ТаблицаСоответствияТоваров);
	Параметры.Свойство("ДополнительныеКоды"              , ДополнительныеКоды);
	Параметры.Свойство("ЗаявкаНаРемонтОбъект"            , ЗаявкаНаРемонтОбъект);
	Параметры.Свойство("ИтогоПоДокументу"                , ИтогоПоДокументу);
	
	ЗагрузкаВЗаявкуНаРемонт = (ЗаявкаНаРемонтОбъект <> Неопределено);
	ДокументЗагрузки = ?(ЗагрузкаВЗаявкуНаРемонт, ЗаявкаНаРемонтОбъект, ЗаказНарядОбъект);
	ИмяДокумента = ?(ЗагрузкаВЗаявкуНаРемонт, "ЗаявкаНаРемонт", "ЗаказНаряд");
	
	РежимыЗагрузкиТаблицЗагружать = Перечисления.РежимыЗагрузкиТаблиц.Загружать;
	
	ДополнительныеПараметрыДокументов.Свойство("КурсИсходнойВалюты", КурсКалькуляции);
	Если НЕ ЗначениеЗаполнено(КурсКалькуляции) Тогда
		КурсКалькуляции = 1;
	КонецЕсли;
	
	ДополнительныеПараметрыДокументов.Свойство("ВалютаКалькуляции", ВалютаРасчета);
	ДополнительныеПараметрыДокументов.Свойство("НормочасОкраски"  , НормочасОкраски);
	ДополнительныеПараметрыДокументов.Свойство("РПВЧас"           , РПВЧас);
	
	Если ЗначениеЗаполнено(НормочасОкраски) И ЗначениеЗаполнено(РПВЧас) Тогда
		СтоимостьОдногоРП = НормочасОкраски/РПВЧас;
	ИначеЕсли ЗначениеЗаполнено(НормочасОкраски) Тогда
		СтоимостьОдногоРП = НормочасОкраски;
	КонецЕсли;
	
	#Область Определение_причины_обращения
	
	// определим идентификатор причины обращения
	ИдентификаторПричиныОбращения = "";
	ОпределитьИдентификаторПричиныОбращения(Объект, ДокументЗагрузки, ИдентификаторПричиныОбращения);
	
	#КонецОбласти
	
	ПараметрыДействия = Новый Структура("НеРассчитыватьСкидки,НеРассчитыватьБонусы", Истина, Истина);
	
	#Область Загрузка_авторабот
	
	СуммаСкидокРабот = 0; СтрокаДопИнформации = ""; ОбщаяСуммаРабот = 0;
	НормоЧасПоУмолчанию =  ПраваИНастройкиПользователя.Значение(ПланыВидовХарактеристик.ПраваИНастройки.НормочасПоУмолчанию);
	
	// Заполняем автоработы
	Если Объект.РежимЗагрузкиАвторабот = РежимыЗагрузкиТаблицЗагружать Тогда
		ДокументЗагрузки.Автоработы.Очистить();
	КонецЕсли;
	
	Для Каждого СтрокаАвтоработы Из ТаблицаСоответствияАвторабот Цикл
		Отказ = Ложь;
		
		Если СтрокаАвтоработы.СтоимостьРабот < 0 Тогда
			СуммаСкидокРабот = СуммаСкидокРабот + СтрокаАвтоработы.СтоимостьРабот;
			Продолжить;
		КонецЕсли;
		
		ТипРемонтаВрег = ВРег(СтрокаАвтоработы.ТипРемонта);
		Если НЕ ЗначениеЗаполнено(СтрокаАвтоработы.СтоимостьРабот)
			И (ТипРемонтаВрег = "L" ИЛИ ТипРемонтаВрег = "LI" ИЛИ ТипРемонтаВрег = "LI1" ИЛИ СтрНачинаетсяС(ТипРемонтаВрег, "LE")) Тогда
			СтрокаАвтоработы.СтоимостьРабот = НормочасОкраски*СтрокаАвтоработы.КоличествоРП;
			Если НЕ ЗначениеЗаполнено(СтрокаАвтоработы.ЦенаРубли) Тогда
				СтрокаАвтоработы.ЦенаРубли = СтрокаАвтоработы.СтоимостьРабот/РПВЧас;
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(СтрокаАвтоработы.СтоимостьРабот) Тогда
			ТекстСообщения = СтрШаблон(НСтр("ru = 'В калькуляции для работы <%1>  не указана стоимость.'"),
			СтрокаАвтоработы.НаименованиеРаботы);
			
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,,,,Отказ);
		КонецЕсли;
		
		Если ТипРемонтаВрег<>"S" И ТипРемонтаВрег<>"LM" И ТипРемонтаВрег<>"IM" И СтрокаАвтоработы.КодДетали<>"1000"
			И СтрокаАвтоработы.КоличествоРП = 0 Тогда
			
			ТекстСообщения = СтрШаблон(НСтр("ru = 'В калькуляции для работы <%1> не указано количество рабочих позиций.'"),
			СтрокаАвтоработы.НаименованиеРаботы);
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,,,,Отказ);
			
		КонецЕсли;
		
		Если Отказ Тогда Продолжить; КонецЕсли;
		
		НоваяСтрока = ДокументЗагрузки.Автоработы.Добавить();
		НоваяСтрока.ИдентификаторПричиныОбращения = ИдентификаторПричиныОбращения;
		НоваяСтрока.ИдентификаторРаботы           = Новый УникальныйИдентификатор;
		НоваяСтрока.Авторабота                    = СтрокаАвтоработы.Авторабота;
		Документы[ИмяДокумента].АвтоработыАвтоработаПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
		
		НоваяСтрока.Количество = 1;
		Если ТипРемонтаВрег="S" ИЛИ ТипРемонтаВрег="LM" ИЛИ ТипРемонтаВрег="IM" ИЛИ СтрокаАвтоработы.КодДетали = "1000" Тогда
			НоваяСтрока.Нормочас    = Справочники.Нормочасы.Рубль;
			НоваяСтрока.Коэффициент = 1;
			НоваяСтрока.Цена        = СтрокаАвтоработы.ЦенаРубли;
		Иначе		
			НоваяСтрока.Нормочас    = ?(ЗначениеЗаполнено(НормоЧасПоУмолчанию), НормоЧасПоУмолчанию, Справочники.Нормочасы.Рубль);
			НоваяСтрока.Коэффициент = СтрокаАвтоработы.КоличествоРП/РПВЧас;
			НоваяСтрока.Цена        = ?(СтрокаАвтоработы.КоличествоРП = 0, 0, (СтрокаАвтоработы.ЦенаРубли*РПВЧас)/СтрокаАвтоработы.КоличествоРП);
		КонецЕсли;
		Документы[ИмяДокумента].АвтоработыЦенаПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
		
		Если НЕ ЗначениеЗаполнено(НоваяСтрока.СтавкаНДС) Тогда
			НоваяСтрока.СтавкаНДС = Справочники.СтавкиНДС.ОсновнаяСтавкаНДС;
			Документы[ИмяДокумента].АвтоработыСтавкаНДСПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
		КонецЕсли;
		
		НоваяСтрока.СуммаВсего = НоваяСтрока.Сумма;
		Документы[ИмяДокумента].АвтоработыСуммаВсегоПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
		
		ОбщаяСуммаРабот = ОбщаяСуммаРабот + НоваяСтрока.СуммаВсего;
		
	КонецЦикла;
	
	#КонецОбласти
	
	#Область Загрузка_товаров
	
	Если Объект.РежимЗагрузкиДеталей = РежимыЗагрузкиТаблицЗагружать Тогда
		ДокументЗагрузки.Товары.Очистить();
	КонецЕсли;
	
	Для Каждого СтрокаТоваров Из ТаблицаСоответствияТоваров Цикл
		Отказ = Ложь;
		
		Если НЕ ЗначениеЗаполнено(СтрокаТоваров.СтоимостьДетали) Тогда
			ТекстСообщения = СтрШаблон(НСтр("ru = 'В калькуляции для детали <%1> не указана стоимость.'"),
			СтрокаТоваров.Номенклатура);
			
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,,,, Отказ);
		КонецЕсли;
		
		Если Отказ Тогда Продолжить; КонецЕсли;
		
		НоваяСтрока = ДокументЗагрузки.Товары.Добавить();
		НоваяСтрока.ИдентификаторПричиныОбращения = ИдентификаторПричиныОбращения;
		НоваяСтрока.Номенклатура                  = СтрокаТоваров.Номенклатура;
		Документы[ИмяДокумента].ТоварыНоменклатураПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
		
		НоваяСтрока.Количество = ?(СтрокаТоваров.КоличествоДеталей > 0, СтрокаТоваров.КоличествоДеталей, 1);
		Если НЕ ЗначениеЗаполнено(НоваяСтрока.Коэффициент) Тогда
			НоваяСтрока.Коэффициент = 1;
		КонецЕсли;
		//НоваяСтрока.УправляющийКод = СтрокаТоваров.КодДетали;
		
		Если НоваяСтрока.Количество <> 0 Тогда
			НоваяСтрока.Цена = СтрокаТоваров.ЦенаРубли/НоваяСтрока.Количество;
			Документы[ИмяДокумента].ТоварыЦенаПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
			
			Если НЕ ЗначениеЗаполнено(НоваяСтрока.СтавкаНДС) Тогда
				НоваяСтрока.СтавкаНДС = Справочники.СтавкиНДС.ОсновнаяСтавкаНДС;
				Документы[ИмяДокумента].ТоварыСтавкаНДСПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
			КонецЕсли;
		КонецЕсли;
		
		НоваяСтрока.СуммаВсего = НоваяСтрока.Сумма;
		Документы[ИмяДокумента].ТоварыСуммаВсегоПриИзменении(ДокументЗагрузки, НоваяСтрока, ПараметрыДействия);
		
	КонецЦикла;
	
	#КонецОбласти
	
	ПерерасчитатьСтроки = Ложь;
	
	#Область Дополнительные_коды
	
	// обработка выполняется только если режим загрузки обоих таблиц "Загружать"
	Если ДополнительныеКоды.Количество() > 0 И
		Объект.РежимЗагрузкиАвторабот = РежимыЗагрузкиТаблицЗагружать И
		Объект.РежимЗагрузкиДеталей = РежимыЗагрузкиТаблицЗагружать Тогда
		
		// посчитаем суммы для распределения
		БазаРасчетаТовары     = ДокументЗагрузки.Товары.Итог("СуммаВсего");
		БазаРасчетаАвтоработы = ДокументЗагрузки.Автоработы.Итог("СуммаВсего");
		БазаРасчетаОкраска    = 0;
		Для Каждого Авторабота Из ДокументЗагрузки.Автоработы Цикл
			Если Авторабота.Авторабота.ЭтоОкраска Тогда
				БазаРасчетаОкраска = БазаРасчетаОкраска + Авторабота.СуммаВсего;
			КонецЕсли;
		КонецЦикла;
		
		// Расчитаем суммы доп. кодов
		ТипыНачисленийДопКодовПроцент            = Перечисления.ТипыНачисленийДопКодов.Процент;
		ТипыНачисленийДопКодовСумма              = Перечисления.ТипыНачисленийДопКодов.Сумма;
		ТипыБазДляРасчетаДопКодовТовары          = Перечисления.ТипыБазДляРасчетаДопКодов.Товары;
		ТипыБазДляРасчетаДопКодовРаботы          = Перечисления.ТипыБазДляРасчетаДопКодов.Работы;
		ТипыБазДляРасчетаДопКодовРаботыПоОкраске = Перечисления.ТипыБазДляРасчетаДопКодов.РаботыПоОкраске;
		ТипыБазДляРасчетаДопКодовРаботыПоРемонту = Перечисления.ТипыБазДляРасчетаДопКодов.РаботыПоРемонту;
		ТипыБазДляРасчетаДопКодовТоварыИРаботы   = Перечисления.ТипыБазДляРасчетаДопКодов.ТоварыИРаботы;
		
		Для Каждого ДопКод Из ДополнительныеКоды Цикл
			Если ДопКод.Ссылка.ТипНачисления = ТипыНачисленийДопКодовПроцент Тогда
				Если ДопКод.Ссылка.БазаДляРасчета = ТипыБазДляРасчетаДопКодовТовары Тогда
					База = ?(НЕ ДопКод.Ссылка.СкидкаНаценка, -БазаРасчетаТовары, БазаРасчетаТовары);
				ИначеЕсли ДопКод.Ссылка.БазаДляРасчета = ТипыБазДляРасчетаДопКодовРаботы Тогда
					База = ?(НЕ ДопКод.Ссылка.СкидкаНаценка, -БазаРасчетаАвтоработы, БазаРасчетаАвтоработы);
				ИначеЕсли ДопКод.Ссылка.БазаДляРасчета = ТипыБазДляРасчетаДопКодовРаботыПоОкраске Тогда
					База = ?(НЕ ДопКод.Ссылка.СкидкаНаценка, -БазаРасчетаОкраска, БазаРасчетаОкраска);
				ИначеЕсли ДопКод.Ссылка.БазаДляРасчета = ТипыБазДляРасчетаДопКодовРаботыПоРемонту Тогда
					База = ?(НЕ ДопКод.Ссылка.СкидкаНаценка, -(БазаРасчетаАвтоработы-БазаРасчетаОкраска), (БазаРасчетаАвтоработы-БазаРасчетаОкраска));
				ИначеЕсли ДопКод.Ссылка.БазаДляРасчета = ТипыБазДляРасчетаДопКодовТоварыИРаботы Тогда
					База = ?(НЕ ДопКод.Ссылка.СкидкаНаценка, -(БазаРасчетаТовары+БазаРасчетаАвтоработы), (БазаРасчетаТовары+БазаРасчетаАвтоработы));
				КонецЕсли;
				
				ДопКод.Сумма = База/100*ДопКод.Значение;
			ИначеЕсли ДопКод.Ссылка.ТипНачисления = ТипыНачисленийДопКодовСумма Тогда
				ДопКод.Сумма = ?(НЕ ДопКод.Ссылка.СкидкаНаценка, -ДопКод.Значение, ДопКод.Значение);
			Иначе
				ДопКод.Сумма = 0;
			КонецЕсли;
		КонецЦикла;
		
		РаспределитьНаТовары = 0; РаспределитьНаАвтоработы = 0;
		Для Каждого ДопКод Из ДополнительныеКоды Цикл
			Если ДопКод.СпособРаспределения = Перечисления.ТипыРаспределенияДопКодов.НаТовары Тогда
				РаспределитьНаТовары = РаспределитьНаТовары + ДопКод.Сумма;
			ИначеЕсли ДопКод.СпособРаспределения = Перечисления.ТипыРаспределенияДопКодов.НаРаботы Тогда
				РаспределитьНаАвтоработы = РаспределитьНаАвтоработы + ДопКод.Сумма;
			Иначе // на обе ТЧ
				ВремСумма = Окр(ДопКод.Сумма/2,2);
				РаспределитьНаТовары = РаспределитьНаТовары + ВремСумма;
				РаспределитьНаАвтоработы = РаспределитьНаАвтоработы + (ДопКод.Сумма - ВремСумма);
			КонецЕсли;
		КонецЦикла;
		
		СтруктураПараметров 						= БонусныеПрограммыСервер.СоздатьПараметрыРаспределитьСуммуПоТаблице();
		СтруктураПараметров.Таблица 				= ДокументЗагрузки.Товары;
		СтруктураПараметров.СуммаРаспределения 		= РаспределитьНаТовары;
		СтруктураПараметров.КолонкаРаспределения 	= "СуммаВсего";
		
		Если РаспределитьНаТовары <> 0 Тогда
			БонусныеПрограммыСервер.РаспределитьСуммуПоТаблице(СтруктураПараметров);
			ПерерасчитатьСтроки = Истина;
		КонецЕсли;
		
		СтруктураПараметров.Таблица 				= ДокументЗагрузки.Автоработы;
		СтруктураПараметров.СуммаРаспределения 		= РаспределитьНаАвтоработы;
		
		Если РаспределитьНаАвтоработы <> 0 Тогда
			БонусныеПрограммыСервер.РаспределитьСуммуПоТаблице(СтруктураПараметров);
			ПерерасчитатьСтроки = Истина;
		КонецЕсли;
	КонецЕсли;
	
	#КонецОбласти
	
	ВсегоПоДокументу = ДокументЗагрузки.Товары.Итог("СуммаВсего") + ДокументЗагрузки.Автоработы.Итог("СуммаВсего");
	
	ДельтаСумм = 0;
	Если НЕ ЗагрузкаВЗаявкуНаРемонт Тогда
		ДельтаСумм = ЗаказНарядОбъект.СогласованнаяСумма - ВсегоПоДокументу;
	ИначеЕсли ИтогоПоДокументу <> Неопределено Тогда
		ДельтаСумм = ИтогоПоДокументу - ВсегоПоДокументу;
	КонецЕсли;
	
	Если ДельтаСумм <> 0
		И Объект.РежимЗагрузкиАвторабот = РежимыЗагрузкиТаблицЗагружать
		И Объект.РежимЗагрузкиДеталей = РежимыЗагрузкиТаблицЗагружать Тогда
		
		// получим суммы. Распредение идет только на работы.
		РаспределитьНаАвтоработы = ДельтаСумм;
		
		СтруктураПараметров                      = БонусныеПрограммыСервер.СоздатьПараметрыРаспределитьСуммуПоТаблице();
		СтруктураПараметров.Таблица              = ДокументЗагрузки.Автоработы;
		СтруктураПараметров.СуммаРаспределения   = РаспределитьНаАвтоработы;
		СтруктураПараметров.КолонкаРаспределения = "СуммаВсего";
		СтруктураПараметров.ВМинус               = Ложь;
		БонусныеПрограммыСервер.РаспределитьСуммуПоТаблице(СтруктураПараметров);
		
		ПерерасчитатьСтроки = Истина;
	КонецЕсли;
	
	Если ПерерасчитатьСтроки Тогда
		Для Каждого Авторабота Из ДокументЗагрузки.Автоработы Цикл
			Документы[ИмяДокумента].АвтоработыСуммаВсегоПриИзменении(ДокументЗагрузки, Авторабота, ПараметрыДействия);
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ ЗагрузкаВЗаявкуНаРемонт Тогда
		Документы.ЗаказНаряд.ПерерасчетСуммыСкидкиБонусами(ДокументЗагрузки);
		Документы.ЗаказНаряд.РассчитатьСуммуСкидкиНаценки(ДокументЗагрузки);
	КонецЕсли;
	
	ВсегоПоДокументу = Документы[ИмяДокумента].РассчитатьИтогиОперации(ДокументЗагрузки).СуммаДокумента;
	
КонецПроцедуры

// Получить тип дела для выгрузки Заказ-наряда в AudaPad Web
//
// Параметры:
//  ЗаказНаряд	 - ДокументСсылка.ЗаказНаряд - Документ, для которого необъодимо получить тип дела.
// 
// Возвращаемое значение:
//  Строка - представление типа дела из вида ремонта для передачи.
//
Функция ТипДелаЗаказНаряда(ЗаказНаряд) Экспорт
	
	ТипДела = Неопределено;
	Если ТипЗнч(ЗаказНаряд) = Тип("ДокументСсылка.ЗаказНаряд")
		ИЛИ ТипЗнч(ЗаказНаряд) = Тип("ДокументСсылка.ЗаявкаНаРемонт") Тогда
		ТипДела = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
			ЗаказНаряд,
			"ВидРемонта.ТипДелаВAudaPadWeb");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ТипДела) Тогда
		ТипДела = ТипДелаВAudaPadWebПоУмолчанию();
	КонецЕсли;
	
	Возврат ПредставлениеТипаДелаВAudaPadWeb(ТипДела);
	
КонецФункции // ТипДелаЗаказНаряда()

// Получение доступности функионала "Обмен с AudaPad Web"
// 
// Возвращаемое значение:
//  Булево - Признак того, что доступна подсистема или нет.
//
Функция ДоступенОбменСAudaPadWeb() Экспорт
	
	Попытка
		// При первичном заполнении базы, работы фонового задания - когда ключ не доступен
		// и не инициализирован параметр сеанса ПараметрыСеанса.МаскаЛицензирования
		ДоступенОбменСAudaPadWeb = ПолучитьФункциональнуюОпцию(
			"ДоступенОбменСAudaPadWeb",
			Новый Структура("ДоступностьПодсистемПоКлючуМаскаКлюча", ПараметрыСеанса.МаскаЛицензирования)
		);
	Исключение
		ДоступенОбменСAudaPadWeb = Истина;
	КонецПопытки;
	
	Возврат ДоступенОбменСAudaPadWeb;
	
КонецФункции

#Область РаботаСXDTOОбъектами

// Сериализует известные платформе типы в xml
//
// Параметры:
//  Значение - Произвольный - сериализуемое значение.
// 
// Возвращаемое значение:
//  Строка - сериализованное значение.
//
Функция ЗначениеВСтрокуXML(Знач Значение) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку(Новый ПараметрыЗаписиXML(, , Ложь, Ложь, ""));
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, Значение);
	
	// Платформенный сериализатор позволяет записать в значение атрибутов перенос строки
	Возврат СтрЗаменить(ЗаписьXML.Закрыть(), Символы.ПС, "&#10;");
КонецФункции

// Десериализует значение из xml в платформенный тип.
//
// Параметры:
//  Текст - Строка - xml значение.
// 
// Возвращаемое значение:
//  Произвольный - значение.
//
Функция ЗначениеИзСтрокиXML(Знач Текст) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Текст);
	Возврат ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Получить свойство из коллекции по пути
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Коллекция;
//  ПутьКСвойству - Строка - Путь к свойству в коллекции.
// 
// Возвращаемое значение:
//   Произвольный - Значение.
//
Функция ПолучитьСвойствоXDTO(Знач ОбъектXDTO, Знач ПутьКСвойству) Экспорт
	
	ВсеОК = Истина;
	ПутьКСвойству = СтрРазделить(ПутьКСвойству, ".");
	
	Для Каждого ПромежуточноеСвойство Из ПутьКСвойству Цикл
		
		Если
			ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO")
			И ОбъектXDTO.Свойства().Получить(ПромежуточноеСвойство) <> Неопределено
		Тогда
		
			Попытка
			
				ОбъектXDTO = ОбъектXDTO.ПолучитьXDTO(ПромежуточноеСвойство);
			
			Исключение
				
				СписокXDTO = ОбъектXDTO.ПолучитьСписок(ПромежуточноеСвойство);
				
				Если СписокXDTO.Количество() = 0 Тогда
					
					ОбъектXDTO = Неопределено;
					
				Иначе
					
					ОбъектXDTO = СписокXDTO.ПолучитьXDTO(0);
					
				КонецЕсли;
				
			КонецПопытки;
			
			Если ОбъектXDTO <> Неопределено Тогда
				
				Продолжить;
				
			КонецЕсли;
			
		КонецЕсли;
			
		ВсеОК = Ложь;
		Прервать;
			
	КонецЦикла;
	
	Если ВсеОК И ТипЗнч(ОбъектXDTO) = Тип("ЗначениеXDTO") Тогда
		
		Возврат ОбъектXDTO.Значение;
		
	ИначеЕсли ВсеОК И ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		
		Возврат ВытянутьСкрытоеЗначение(ОбъектXDTO);
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Преобразует строковое значение в объект ИБ
//
// Параметры:
//  Значение - Строка - Преобразовываемое значение;
//  Тип      - Строка - Желаемый тип значения.
// 
// Возвращаемое значение:
//   Произвольный - Значение.
//
Функция ЗначениеXMLВ1С(Значение, Тип) Экспорт
	
	Если ПустаяСтрока(Значение) Тогда
		Возврат Неопределено;
	ИначеЕсли СтрНачинаетсяС(Тип, "Число") Тогда
		Знак = ?(СтрНачинаетсяС(Значение, "-"), -1, 1);
		РабочееЗначение = СтрЗаменить(Значение, "-", "");
		РабочееЗначение = СтрЗаменить(РабочееЗначение, "+", "");
		РабочееЗначение = СтрЗаменить(РабочееЗначение, Символы.НПП, "");
		
		Возврат Знак*Число(СокрЛП(РабочееЗначение));
	ИначеЕсли СтрНачинаетсяС(Тип, "Дата") Тогда
		РабочееЗначение = Значение;
		РабочееЗначение = СтрЗаменить(РабочееЗначение, "-", "");
		РабочееЗначение = СтрЗаменить(РабочееЗначение, " ", "");
		РабочееЗначение = СтрЗаменить(РабочееЗначение, ":", "");
		РабочееЗначение = СтрЗаменить(РабочееЗначение, ".", "");
		
		Возврат Дата(РабочееЗначение);
	ИначеЕсли СтрНачинаетсяС(Тип, "УникальныйИдентификатор") Тогда
		Возврат Новый УникальныйИдентификатор(Значение);
	ИначеЕсли СтрНачинаетсяС(Тип, "Валюта") Тогда
		// Попытаемся найти по наименованию
		Результат = Справочники.Валюты.НайтиПоНаименованию(Значение, Истина);
		
		Если НЕ Результат.Пустая() Тогда
			Возврат Результат;
		Иначе
			// Определение кода валюта по наименованию
			Если ВРег(Значение)="RUR" ИЛИ ВРег(Значение)="RUB" Тогда
				ВероятныйКод = "643";
			ИначеЕсли ВРег(Значение)="USD" Тогда 
				ВероятныйКод = "840";
			ИначеЕсли ВРег(Значение)="EUR" Тогда 
				ВероятныйКод = "978";
			Иначе
				ВероятныйКод = 0;
			КонецЕсли;
			
			Результат = Справочники.Валюты.НайтиПоКоду(ВероятныйКод, Истина);
			
			Если НЕ Результат.Пустая() Тогда
				Возврат Результат;
			Иначе
				// По коду и наименованию валюта не найдена,
				// создадим валюту
				НовыйОбъект = Справочники.Валюты.СоздатьЭлемент();
				Если ВероятныйКод = 0 Тогда
					НовыйОбъект.УстановитьНовыйКод();
				Иначе
					НовыйОбъект.Код = ВероятныйКод;
				КонецЕсли;
				
				НовыйОбъект.Заполнить(Неопределено);
				НовыйОбъект.Наименование       = Значение;
				НовыйОбъект.НаименованиеПолное = Значение;
				Попытка
					НовыйОбъект.Записать();
					Результат = НовыйОбъект.Ссылка;
					Возврат Результат;
				Исключение
					Результат = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Значение;
КонецФункции

#КонецОбласти

#Область ДлительныеОперации

// Запускает обновление фоновых заданий в фоне
//
// Параметры:
//  Параметры - Структура - Настройки операции:
//    * ПараметрыПодключенияОбъекта - Структура - параметры подключения к серверу audatex;
//    * Фильтры - Строка - фильтр для дел.
//  АдресХранилища - Строка - адрес во временном хранилище по которому будет расположен результат.
//
Процедура ВыполнитьОбновлениеЗаданийВФоне(Параметры, АдресХранилища) Экспорт
	
	СписокЗаданийPayLoad = "";
	Ответ = ЗагрузитьСписокЗаданий(Параметры.ПараметрыПодключенияОбъекта, Параметры.Фильтры, СписокЗаданийPayLoad);

	Если Ответ.Свойство("Успех") И НЕ Ответ.Успех Тогда
		
		ПоместитьВоВременноеХранилище(Ответ, АдресХранилища);
		Возврат;
		
	КонецЕсли;
	
	ПоместитьВоВременноеХранилище(СписокЗаданийPayLoad, АдресХранилища);
	
КонецПроцедуры

// Запускает обновление фоновых заданий в фоне
//
// Параметры:
//  Параметры - Структура - Настройки операции:
//    * СписокКалькуляций - Таблица - список калькуляций, структуру таблицы смотри в объекте ОбменС;
//    * ИдентификаторДела - Строка - уникальный идентификатор дела;
//    * ИдентификаторЗадания - Строка - уникальный идентификатор дела;
//    * ПараметрыПодключения - Структура - параметры подключения к серверу  audatex;
//  АдресХранилища - Строка - адрес во временном хранилище по которому будет расположен результат.
//
Процедура ВыполнитьОбновлениеКалькуляцийЗаданияВФоне(Параметры, АдресХранилища) Экспорт
	
	СписокКалькуляций = Параметры.СписокКалькуляций;
	Отбор = Новый Структура("ИдентификаторДела", Параметры.ИдентификаторДела);
	СтрокиКэша = СписокКалькуляций.НайтиСтроки(Отбор);
	
	Для Каждого УдаляемаяСтрока Из СтрокиКэша Цикл
		
		СписокКалькуляций.Удалить(УдаляемаяСтрока);
		
	КонецЦикла;
	
	СодержаниеЗадания = "";
	Результат = ЗагрузитьЗадание(Параметры.ИдентификаторЗадания, Параметры.ПараметрыПодключения, СодержаниеЗадания);
	
	Если Результат.Свойство("Успех") И НЕ Результат.Успех Тогда
		
		ПоместитьВоВременноеХранилище(Результат, АдресХранилища);
		Возврат;
		
	КонецЕсли;
	
	РазобратьСоставЗадания(СодержаниеЗадания, Параметры.ИдентификаторДела, СписокКалькуляций);
	
	Параметры.СписокКалькуляций = СписокКалькуляций;
	ПоместитьВоВременноеХранилище(Параметры, АдресХранилища);
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НовыйWSПроксиЗаданий(ПараметрыПодключения)
	
	УстановитьПривилегированныйРежим(Истина);
	ПроксиЗаданий = Обработки.ТранспортОбменаСAudaPadWeb.Создать();
	ПроксиЗаданий.Инициализировать(ПараметрыПодключения.АдресСервера, ПараметрыПодключения.РесурсЗаданий, Истина);
	ПроксиЗаданий.УстановитьЗаголовкиПоУмолчанию();
	Возврат ПроксиЗаданий;
	
КонецФункции

Функция WSПроксиПрикреплений(ПараметрыПодключения, ПроксиЗаданий)
	
	УстановитьПривилегированныйРежим(Истина);
	ПроксиЗаданий = Обработки.ТранспортОбменаСAudaPadWeb.Создать();
	ПроксиЗаданий.Инициализировать(ПараметрыПодключения.АдресСервера, ПараметрыПодключения.РесурсПрикреплений, Истина);
	Возврат Новый Структура("Успех,Сообщение", Истина, "");
	
КонецФункции

Функция ДайТекстСообщенияОбОшибке(ОтветСервера)
	
	ТипОтвета = ТипЗнч(ОтветСервера.message);
	
	Если ТипОтвета = Тип("ОбъектXDTO") Тогда
		
		Возврат ОтветСервера.message.text;
		
	ИначеЕсли ТипОтвета = Тип("СписокXDTO") Тогда
		
		СтрокиСообщения = Новый Массив();
		
		Для каждого СтрокаСообщения Из ОтветСервера.message Цикл
			
			Если ТипЗнч(СтрокаСообщения) = Тип("ОбъектXDTO") Тогда
				
				Попытка
					
					СтрокиСообщения.Добавить(СтрокаСообщения.localizedText);
					
				Исключение
					
					ЗаписьЖурналаРегистрации(
						КатегорияОшибокНеУдалосьРазобратьОтвет(),
						УровеньЖурналаРегистрации.Ошибка,
						,
						Строка(СтрокаСообщения),
						ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
					);
					
				КонецПопытки;
				
			Иначе
				
				СтрокиСообщения.Добавить(СтрокаСообщения);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат СтрСоединить(СтрокиСообщения, Символы.ПС);
		
	Иначе
		
		Возврат НСтр("ru='Нет данных'");
		
	КонецЕсли;
	
КонецФункции

Функция ВытянутьСкрытоеЗначение(ОбъектXDTO)
	
	ТекстXML = ЗначениеВСтрокуXML(ОбъектXDTO);
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.Текст Тогда
			Возврат Чтение.Значение;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Процедура РазобратьСоставЗадания(СодержаниеЗадания, ИдентификаторДела, СписокКалькуляций) Экспорт
	ОбъектXDTO = ЗначениеИзСтрокиXML(СодержаниеЗадания);
	
	// проверим наличие калькуляций
	Если ОбъектXDTO.Свойства().Получить("CalculationList") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// получим данные автомобиля
	ДанныеАвтомобиля = Новый Структура;
	ДанныеАвтомобиля.Вставить("Идентификатор",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleIdentification.ItemId"));
	ДанныеАвтомобиля.Вставить("VIN",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleIdentification.VIN"));
	ДанныеАвтомобиля.Вставить("Производитель",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleIdentification.ManufacturerName"));
	ДанныеАвтомобиля.Вставить("Модель",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleIdentification.ModelName"));
	ДанныеАвтомобиля.Вставить("Подмодель",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleIdentification.SubModelName"));
	ДанныеАвтомобиля.Вставить("Номер",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleAdmin.PlateNumber"));
	ДанныеАвтомобиля.Вставить("ДатаВыпуска",
		ЗначениеXMLВ1С(ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleAdmin.BuildDate"), "Дата"));
	ДанныеАвтомобиля.Вставить("Пробег",
		ЗначениеXMLВ1С(ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleEngineering.Mileage"), "Число"));
	ДанныеАвтомобиля.Вставить("Пробег_Измерение",
		ПолучитьСвойствоXDTO(ОбъектXDTO, "BasicClaimData.Vehicle.VehicleEngineering.MileageUnit"));
	
	Если ТипЗнч(ОбъектXDTO.CalculationList.CLASSCalculation) = Тип("СписокXDTO") Тогда
		XDTOСписокКалькуляций = ОбъектXDTO.CalculationList.CLASSCalculation;
	Иначе
		XDTOСписокКалькуляций = Новый Массив;
		XDTOСписокКалькуляций.Добавить(ОбъектXDTO.CalculationList.CLASSCalculation);
	КонецЕсли;
	
	Для Каждого ДанныеКалькуляции Из XDTOСписокКалькуляций Цикл
		НоваяСтрока = СписокКалькуляций.Добавить();
		НоваяСтрока.ИдентификаторДела   = ИдентификаторДела;
		НоваяСтрока.ДанныеКалькуляции   = ЗначениеВСтрокуXML(ДанныеКалькуляции);
		НоваяСтрока.АвтомобильСтруктура = ДанныеАвтомобиля;
		
		ОбработатьНовуюСтрокуКалькуляции(НоваяСтрока, СписокКалькуляций);
	КонецЦикла;
КонецПроцедуры

Процедура ОбработатьНовуюСтрокуКалькуляции(Строка, СписокКалькуляций)
	УдалитьСтроку = Ложь;
	
	КалькуляцияXDTO = Неопределено;
	Если ПустаяСтрока(Строка.ДанныеКалькуляции) Тогда
		УдалитьСтроку = Истина;
	Иначе
		КалькуляцияXDTO = ЗначениеИзСтрокиXML(Строка.ДанныеКалькуляции);
	КонецЕсли;
	
	Если НЕ УдалитьСтроку Тогда
		// реквизиты строки, их обязательность и путь в объекте xdto
		РеквизитыСтроки = Новый Соответствие;
		РеквизитыСтроки.Вставить(
			"РПВЧас",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.GlobalData.CalcParam.TimeBase.Val",
				Ложь,
				"Число"
			)
		);
		РеквизитыСтроки.Вставить(
			"НаценкаНаДетали",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.CalcData.FinalCalc.FCPart.FCSundry.PCofParts.PCofPart.PC.Val",
				Ложь,
				"Число"
			)
		);
		РеквизитыСтроки.Вставить(
			"КурсИсходнойВалюты",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.GlobalData.CalcParam.CurDtl.ExChgDtl.ExChgRate.Rate.Val",
				Ложь,
				"Число"
			)
		);
		РеквизитыСтроки.Вставить(
			"ИдентификаторКалькуляции",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CalculationId",
				Истина,
				"Строка"
			)
		);
		РеквизитыСтроки.Вставить(
			"НомерДела",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.GlobalData.CalcIdent.CalcNo",
				Истина,
				"Строка"
			)
		);
		РеквизитыСтроки.Вставить(
			"ДатаЦен",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.GlobalData.CalcParam.PPPriceDat",
				Ложь,
				"Дата"
			)
		);
		РеквизитыСтроки.Вставить(
			"ВалютаКалькуляции",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.GlobalData.CalcParam.CurDtl.ISO",
				Ложь,
				"Валюта"
			)
		);
		РеквизитыСтроки.Вставить(
			"ВалютаИсходная",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.GlobalData.CalcParam.CurDtl.ExChgDtl.From.ISO",
				Ложь,
				"Валюта"
			)
		);
		РеквизитыСтроки.Вставить(
			"НормочасАвторабот",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.CalcData.FinalCalc.FCLabor.LaborRates.LaborResults.Rate",
				Ложь,
				"Число"
			)
		);
		РеквизитыСтроки.Вставить(
			"НормочасОкраски",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.CalcData.FinalCalc.FinalCalc.FCPaint.LaborRates.LaborResults.Rate",
				Ложь,
				"Число"
			)
		);
		РеквизитыСтроки.Вставить(
			"НормочасОкраски",
			Новый Структура(
				"Путь,Обязательный,Тип",
				"CLASSResult.CLASSXml.CalcData.FinalCalc.FCPaint.LaborRates.LaborResults.Rate",
				Ложь,
				"Число"
			)
		);
		
		Для Каждого РеквизитСтроки Из РеквизитыСтроки Цикл
			
			ЗначениеРеквизита = ПолучитьСвойствоXDTO(КалькуляцияXDTO, РеквизитСтроки.Значение.Путь);
			
			Если РеквизитСтроки.Значение.Обязательный И НЕ ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
				
				УдалитьСтроку = Истина;
				
			Иначе
				
				Строка[РеквизитСтроки.Ключ] = ЗначениеXMLВ1С(ЗначениеРеквизита, РеквизитСтроки.Значение.Тип);
				
			КонецЕсли;
			
		КонецЦикла;
		
		// дата калькуляции
		ДатаКалькуляции  = ПолучитьСвойствоXDTO(КалькуляцияXDTO, "CLASSResult.CLASSXml.GlobalData.CalcIdent.SystemDat");
		ВремяКалькуляции = ПолучитьСвойствоXDTO(КалькуляцияXDTO, "CLASSResult.CLASSXml.GlobalData.CalcIdent.TimeStamp");
		Если ЗначениеЗаполнено(ВремяКалькуляции) Тогда
			Если НЕ ЗначениеЗаполнено(ДатаКалькуляции) Тогда
				ТекДата = Формат(Дата(1900,1,1), "ДФ=yyyy-MM-dd")+Лев(ВремяКалькуляции,5)+"00";
			Иначе
				ТекДата = Формат(ДатаКалькуляции, "ДФ=yyyy-MM-dd")+Лев(ВремяКалькуляции,5)+"00";
			КонецЕсли;
		Иначе
			ТекДата = ДатаКалькуляции;
		КонецЕсли;
		Строка.ДатаКалькуляции = ЗначениеXMLВ1С(ТекДата, "Дата");
	КонецЕсли;
	
	Если УдалитьСтроку Тогда
		СписокКалькуляций.Удалить(Строка);
	КонецЕсли;
КонецПроцедуры

Функция ПоляСпискаКалькуляций()
	
	Возврат
	"TaskId,CaseId,ClaimNumber,PlateNumber,Creator,TaskStatus,ManufacturerName,ModelName,VehicleOwnerName,VehicleOwnerFirstName,VehicleOwnerLastName,CreationDate,PolicyNumber,LastEditedDateTime,DisplayName,TaskProgress,PolicyHolderLastName,ClaimantLastName,VIN";
	
КонецФункции

Функция КатегорияОшибокНеУдалосьРазобратьОтвет()
	
	Возврат НСтр("ru = 'ОбменСAudaPadWeb.Не удалось разобрать ответ сервера'",
		ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Процедура ОпределитьИдентификаторПричиныОбращения(Объект, ДокументЗагрузки, ИдентификаторПричиныОбращения)
	
	Если Объект.ПричинаОбращения.Пустая() И ДокументЗагрузки.ПричиныОбращения.Количество() > 0 Тогда
		ИдентификаторПричиныОбращения = ДокументЗагрузки.ПричиныОбращения[0].ИдентификаторПричиныОбращения;
	ИначеЕсли НЕ Объект.ПричинаОбращения.Пустая() И ДокументЗагрузки.ПричиныОбращения.Количество() > 0 Тогда
		НайденныеПричины = ДокументЗагрузки.ПричиныОбращения.НайтиСтроки(
			Новый Структура("ПричинаОбращения", Объект.ПричинаОбращения));
		Если НайденныеПричины.Количество() > 0 Тогда
			ИдентификаторПричиныОбращения = НайденныеПричины[0].ИдентификаторПричиныОбращения;
		Иначе
			ИдентификаторПричиныОбращения = Новый УникальныйИдентификатор;
			НоваяПричина = ДокументЗагрузки.ПричиныОбращения.Добавить();
			НоваяПричина.ПричинаОбращения              = Объект.ПричинаОбращения;
			НоваяПричина.ИдентификаторПричиныОбращения = ИдентификаторПричиныОбращения;
			НоваяПричина.ПричинаОбращенияСодержание    = Объект.ПричинаОбращения.ПричинаОбращения;
			НоваяПричина.ТипПричиныОбращения           = Объект.ПричинаОбращения.ТипПричиныОбращения;
			НоваяПричина.ВидРемонтаПричиныОбращения    = Объект.ПричинаОбращения.ВидРемонта;
		КонецЕсли;
	ИначеЕсли НЕ Объект.ПричинаОбращения.Пустая() И ДокументЗагрузки.ПричиныОбращения.Количество() = 0 Тогда
		ИдентификаторПричиныОбращения = Новый УникальныйИдентификатор;
		НоваяПричина = ДокументЗагрузки.ПричиныОбращения.Добавить();
		НоваяПричина.ПричинаОбращения              = Объект.ПричинаОбращения;
		НоваяПричина.ИдентификаторПричиныОбращения = ИдентификаторПричиныОбращения;
		НоваяПричина.ПричинаОбращенияСодержание    = Объект.ПричинаОбращения.ПричинаОбращения;
		Если ПустаяСтрока(НоваяПричина.ПричинаОбращенияСодержание) Тогда
			НоваяПричина.ПричинаОбращенияСодержание = НоваяПричина.ПричинаОбращения;
		КонецЕсли;
		НоваяПричина.ТипПричиныОбращения           = Объект.ПричинаОбращения.ТипПричиныОбращения;
		НоваяПричина.ВидРемонтаПричиныОбращения    = Объект.ПричинаОбращения.ВидРемонта;
	КонецЕсли;
	
КонецПроцедуры

Функция ПредставлениеТипаДелаВAudaPadWeb(ТипДела)
	
	ДоступныеТипыДел = Новый Соответствие;
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.АктОсмотра, "INSPECTIONREPORT");
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.СлесарныйРемонт, "SMR");
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.ЭкспрессКалькуляция, "AUDAEXPRESS");
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.ОСАГО, "OSAGO");
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.КАСКО, "KASKO");
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.КалькуляцияАвтомобиляСПробегом, "USEDCARS");
	ДоступныеТипыДел.Вставить(Перечисления.ТипыДелВAudaPadWeb.Проценка, "ESTIMATE");
	
	Возврат ДоступныеТипыДел.Получить(ТипДела);
	
КонецФункции

#КонецОбласти

