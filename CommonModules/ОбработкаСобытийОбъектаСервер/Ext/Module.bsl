// Общий модуль "Обработка событий объекта (сервер)"

#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ ОБЪЕКТА

// Возвращает признак возможности ввода на основании
//
// Параметры:
//  Объект           - ДанныеФормыСтруктура - Объект, для которого выполняется проверка
//  ДанныеЗаполнения - Произвольный         - Значение, которое используется как основание для заполнения.
//
// Возвращаемое значение:
//  Булево - Ложь, если ввод на основании не возможен, Истина если возможен.
//
Функция ВозможенВводНаОсновании(Объект, ДанныеЗаполнения) Экспорт
	
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(ДанныеЗаполнения));
	
	Возврат ЗначениеЗаполнено(ДанныеЗаполнения) И (НЕ ОбъектМетаданных = Неопределено) 
			И Объект.Метаданные().ВводитсяНаОсновании.Содержит(ОбъектМетаданных);
	
КонецФункции // ВозможенВводНаОсновании()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ПроверитьЗаполнениеРеквизитовОбъекта(Объект, Отказ, ПроверяемыеРеквизиты) Экспорт
	
	// Подготовим список проверяемых реквизитов к заполнению
	ПроверяемыеРеквизиты.Очистить();
	
	// Получим параметры текущего проверяемого объекта
	ОбъектМетаданных    = Объект.Метаданные();
	МенеджерОбъекта     = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОбъектМетаданных.ПолноеИмя());
	ЭтоСправочник       = Метаданные.Справочники.Содержит(ОбъектМетаданных);
	ЭтоДокумент         = Метаданные.Документы.Содержит(ОбъектМетаданных);
	ЭтоРегистр          = Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
	Владелец            = ?(ЭтоСправочник И ЗначениеЗаполнено(Объект.Владелец), Объект.Владелец, Неопределено);
	ПредставлениеСписка = "";
	
	// Получим и установим перечень обязательный к заполнению реквизитов
	Для каждого ОбязательныйРеквизит Из МенеджерОбъекта.ПолучитьОбязательныеРеквизиты(Объект) Цикл
		Если ОбязательныйРеквизит = "Код" И (ЭтоСправочник И ОбъектМетаданных.Автонумерация) Тогда
			Продолжить;
		Иначе
			ПроверяемыеРеквизиты.Добавить(ОбязательныйРеквизит);
		КонецЕсли;
	КонецЦикла;
	
	// Произведем проверку уникальности заполнения реквизитов объекта
	Для каждого УникальныйРеквизит Из МенеджерОбъекта.ПолучитьУникальныеРеквизиты(Объект) Цикл
		
		// Обработаем в зависимости от вида реквизита
		Если ТипЗнч(УникальныйРеквизит.Значение) = Тип("Массив") Тогда
			
			// Создадим структуру отбора для проверки уникальности реквизитов
			ПоляПоискаДублей = Новый Структура();
			Для каждого УникальныйРеквизитТаблицы Из УникальныйРеквизит.Значение Цикл
				ПоляПоискаДублей.Вставить(СокрЛП(УникальныйРеквизитТаблицы));
			КонецЦикла;
			
			// Проверяем целесообразность дальнейших вычислений
			Если ПоляПоискаДублей.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			// Подготовим список для накопления сведений о дублирующихся строках.
			СписокНайденныхДублей = Новый Массив;
			ОбработанныеСтроки    = Новый Соответствие;
			ИмяТабличнойЧасти     = УникальныйРеквизит.Ключ;
			
			// Идем по табличной части
			Для каждого СтрокаТабличнойЧасти Из Объект[ИмяТабличнойЧасти] Цикл
				
				// Пропустим строки уже попавшие в черный список
				Если НЕ ОбработанныеСтроки.Получить(СтрокаТабличнойЧасти) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				// Производим поиск строк удовлетворяющих структуре отбора
				ЗаполнитьЗначенияСвойств(ПоляПоискаДублей, СтрокаТабличнойЧасти);
				НайденныеСтроки = Объект[ИмяТабличнойЧасти].НайтиСтроки(ПоляПоискаДублей);
				
				// Если нашли и их больше 1, то строки не уникальные
				Если НайденныеСтроки.Количество() > 1 Тогда
					
					// Определим номера дублирующихся строк и занесем их в черный список
					НомераСтрокДублей = "";
					Для каждого НайденныйДубль Из НайденныеСтроки Цикл
						НомераСтрокДублей = НомераСтрокДублей + ", " + СокрЛП(НайденныйДубль.НомерСтроки);
						ОбработанныеСтроки.Вставить(НайденныйДубль, Истина);
					КонецЦикла;
					
					// Запоминаем номера найденных дублей
					СписокНайденныхДублей.Добавить(Сред(НомераСтрокДублей, 3));
					
				КонецЕсли;
				
			КонецЦикла;
			
			// Выводим сведения о найденных дублях по текущему ключу поиска
			Если СписокНайденныхДублей.Количество() > 0 Тогда
				
				// Произведем формирование заголовка сообщения об обнаруженных дублях
				ОбъектМетаданныхТаблицы = ОбъектМетаданных.ТабличныеЧасти[ИмяТабличнойЧасти];
				ПредставленияПолей      = "";
				ПредставленияСтрок      = "";
				
				// Получим представление дублирующихся полей
				Для каждого УникальныйРеквизитТаблицы Из УникальныйРеквизит.Значение Цикл
					ПредставленияПолей = ПредставленияПолей + ", " 
						+ ОбъектМетаданныхТаблицы.Реквизиты[УникальныйРеквизитТаблицы].Синоним;
				КонецЦикла;
				
				// Получим представление дублирующихся строк
				Для каждого НайденныеДубли Из СписокНайденныхДублей Цикл
					ПредставленияСтрок = ПредставленияСтрок + Символы.ПС + НСтр("ru = 'Строки:" + " " + НайденныеДубли + "'");
				КонецЦикла;
				
				// Информируем пользователя о найденной коллизии
				ОбщегоНазначения.СообщитьПользователю(
					СтрШаблон(
						НСтр("ru = 'Строки таблицы ""%1"" не уникальны по значению полей (%2)%3'"),
						ОбъектМетаданныхТаблицы.Синоним,
						Сред(ПредставленияПолей, 3), 
						ПредставленияСтрок
					),
					Объект,
					ИмяТабличнойЧасти,
					,
					Отказ
				);
				
			КонецЕсли;
			
		Иначе
			
			// Формируем текст запроса для поиска имеющейся записи таблицы
			ТекстЗапроса = 
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
			|	*
			|ИЗ
			|	" + ОбъектМетаданных.ПолноеИмя() + " КАК Таблица
			|ГДЕ
			|	Таблица.Ссылка <> &Ссылка
			|	И (НЕ Таблица.ПометкаУдаления)";
			
			// Создаем объект запроса и устанавливаем параметры
			Запрос = Новый ПостроительЗапроса(ТекстЗапроса);
			Запрос.ЗаполнитьНастройки();
			Запрос.Параметры.Вставить("Ссылка", Объект.Ссылка);
			
			Запрос.ВыбранныеПоля.Очистить();
			Запрос.ВыбранныеПоля.Добавить("Ссылка");
			
			// Накладываем отбор по реквизиту, уникальность которого требуется проверить
			ЭлементОтбора = Запрос.Отбор.Добавить(УникальныйРеквизит.Ключ);
			ЭлементОтбора.Установить(Объект[УникальныйРеквизит.Ключ], Истина);
			
			// Накладываем дополнительный отбор по владельцу для подчиненных справочников
			Если ЭтоСправочник И ЗначениеЗаполнено(Владелец) Тогда
				ЭлементОтбора = Запрос.Отбор.Добавить("Владелец");
				ЭлементОтбора.Установить(Владелец, Истина);
			КонецЕсли;
			
			// Выполняем запрос
			Запрос.Выполнить();
			
			// Выводим сообщение о не уникальности объекта среди своего списка
			Если НЕ Запрос.Результат.Пустой() Тогда
				
				// Получим представление списка объектов
				Если ПустаяСтрока(ПредставлениеСписка) Тогда
					ПредставлениеСписка = УправлениеДиалогомСервер.ПредставлениеСпискаОбъектов(ОбъектМетаданных);
				КонецЕсли;
				
				// Получим описание метаданных проверяемого реквизита
				ОбъектМетаданныхРеквизита = ОбъектМетаданных.Реквизиты.Найти(УникальныйРеквизит.Ключ);
				Если ОбъектМетаданныхРеквизита = Неопределено Тогда
					ОбъектМетаданныхРеквизита = Метаданные.ОбщиеРеквизиты.Найти(УникальныйРеквизит.Ключ);
				КонецЕсли;
				
				// Проверим уникальные реквизиты для стандартных реквизитов объекта
				Если ОбъектМетаданныхРеквизита = Неопределено Тогда
					Для каждого СтандартныйРеквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
						Если СтандартныйРеквизит.Имя = УникальныйРеквизит.Ключ Тогда
							ОбъектМетаданныхРеквизита = СтандартныйРеквизит;
							Продолжить;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				// Информируем пользователя о найденной коллизии
				ОбщегоНазначения.СообщитьПользователю(
					СтрШаблон(
						НСтр("ru = 'Поле ""%1"" не уникально в пределах ""%2""'"),
						ОбъектМетаданныхРеквизита.Представление(),
						ПредставлениеСписка
					),
					Объект,
					УникальныйРеквизит.Ключ,
					,
					Отказ
				);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ПроверитьЗаполнениеРеквизитовОбъекта()

Процедура ПроверитьПараметрыВыбораРеквизитовОбъекта(Объект, Отказ) Экспорт
	
	// Получим параметры текущего проверяемого объекта
	ОбъектМетаданных = Объект.Метаданные();
	
	// Получим перечень отборов реквизитов
	НакладываемыйОтбор = Новый Массив();
	
	// Проверим параметры выбора для стандартных реквизитов объекта
	Для каждого СтандартныйРеквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора(Объект, СтандартныйРеквизит, Отказ);
	КонецЦикла;
	
	// Проверим параметры выбора для реквизитов объекта
	Для каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора(Объект, Реквизит, Отказ);
	КонецЦикла;
	
	Если Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		
		// Проверим параметры выбора для измерений объекта
		Для каждого Реквизит Из ОбъектМетаданных.Измерения Цикл
			Для каждого Запись Из Объект Цикл
				ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора(Запись, Реквизит, Отказ);
			КонецЦикла;
		КонецЦикла;
		
		// Проверим параметры выбора для ресурсов объекта
		Для каждого Реквизит Из ОбъектМетаданных.Ресурсы Цикл
			Для каждого Запись Из Объект Цикл
				ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора(Запись, Реквизит, Отказ);
			КонецЦикла;
		КонецЦикла;
		
	Иначе
		
		// Проверим параметры выбора для реквизитов табличных частей объекта
		Для каждого Таблица Из ОбъектМетаданных.ТабличныеЧасти Цикл
			
			// таблица дополнительных реквизитов проверке не подвергается
			Если Таблица.Имя = "ДополнительныеРеквизиты" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого Реквизит Из Таблица.Реквизиты Цикл
				Для каждого СтрокаТабличнойЧасти Из Объект[Таблица.Имя] Цикл
					ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора(Объект, Реквизит, Отказ, СтрокаТабличнойЧасти, Таблица.Имя);
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПараметрыВыбораРеквизитовОбъекта()

Процедура ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора(Объект, Реквизит, 
						Отказ, СтрокаТабличнойЧасти = Неопределено, ИмяТабличнойЧасти = "")
	
	ПараметрыВыбораРеквизита = Новый Массив();
	
	// Получим параметры выбора для реквизита
	Для каждого ПараметрВыбора Из Реквизит.ПараметрыВыбора Цикл
		ПараметрыВыбораРеквизита.Добавить(ПараметрВыбора);
	КонецЦикла;
	
	// Получим связи параметров выбора для реквизита
	Для каждого СвязьПараметрВыбора Из Реквизит.СвязиПараметровВыбора Цикл
		ПараметрыВыбораРеквизита.Добавить(СвязьПараметрВыбора);
	КонецЦикла;
	
	// Проверим введенные значения реквизитов на соответствие установленным параметрам выбора.
	Для каждого Параметр Из ПараметрыВыбораРеквизита Цикл
		
		ИмяПоля = Сред(Параметр.Имя, 7);
		
		Если СтрокаТабличнойЧасти = Неопределено Тогда
			Источник = Объект[Реквизит.Имя];
		Иначе
			Источник = СтрокаТабличнойЧасти[Реквизит.Имя];
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(Источник)
			ИЛИ ТипЗнч(Источник) = Тип("Строка")
			ИЛИ НЕ ЕстьРеквизит(Источник, ИмяПоля) Тогда
			Продолжить;
		КонецЕсли;
		
		Если Тип(Параметр) = Тип("ПараметрВыбора") Тогда
			
			Если ТипЗнч(Параметр.Значение) = Тип("ФиксированныйМассив") Тогда
				
				Если НЕ Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Источник)) Тогда
					ЗначениеПоиска = Источник[ИмяПоля];
			 	Иначе
					ЗначениеПоиска = Источник; 	
				КонецЕсли;	
				
				Если Параметр.Значение.Найти(ЗначениеПоиска) = Неопределено Тогда
					
					СписокЗначениеПараметровВыбора = "";
					
					Для Каждого ЭлементМассива Из Параметр.Значение Цикл
						СписокЗначениеПараметровВыбора = СписокЗначениеПараметровВыбора 
							+ ?(ЗначениеЗаполнено(ЭлементМассива), ЭлементМассива, НСтр("ru = '<Пустое значение>'")) + ", ";
					КонецЦикла;					
					
					ОбщегоНазначения.СообщитьПользователю(
						СтрШаблон(
							НСтр("ru = 'Свойство ""%1"" поля ""%2"" может иметь значения: ""%3""'"),
							ИмяПоля,
							Реквизит.Синоним,
							СписокЗначениеПараметровВыбора
						),
						Объект,,, Отказ
					);
					
				КонецЕсли;	
				
			ИначеЕсли НЕ Источник[ИмяПоля] = Параметр.Значение Тогда
				
				ПолучитьСинонимРеквизита(Реквизит, ИмяПоля);
				ОбщегоНазначения.СообщитьПользователю(
					СтрШаблон(
						НСтр("ru = 'Свойство ""%1"" поля ""%2"" должно иметь значение ""%3""'"),
						ИмяПоля,
						Реквизит.Синоним,
						Параметр.Значение
					),
					Объект,,, Отказ
				);
				
			КонецЕсли;
			
		Иначе
			
			// Пропустим все параметры у которых установлен пониженный режим важности связи
			Если Параметр.ИзменениеЗначения = РежимИзмененияСвязанногоЗначения.НеИзменять Тогда
				Продолжить;
			КонецЕсли;
			
			ЧастиПутиКДанным = СтрЗаменить(Параметр.ПутьКДанным, ".", Символы.ПС);
			
			Если СтрЧислоСтрок(ЧастиПутиКДанным) = 1 Тогда
				ЗначениеПоля = Объект[Параметр.ПутьКДанным];
				НомерСтроки  = Неопределено;
			Иначе
				ЗначениеПоля = СтрокаТабличнойЧасти[СтрПолучитьСтроку(ЧастиПутиКДанным, 2)];
				НомерСтроки  = СтрокаТабличнойЧасти.НомерСтроки;
			КонецЕсли;
			
			Если НЕ Источник[ИмяПоля] = ЗначениеПоля Тогда
				
				ПолучитьСинонимРеквизита(Реквизит, ИмяПоля);
				
				Если СтрокаТабличнойЧасти <> Неопределено Тогда
					
					ПутьКЯчейке = СтрШаблон("Объект.%1[%2].%3",ИмяТабличнойЧасти,СтрокаТабличнойЧасти.НомерСтроки - 1,Реквизит.Имя);
					ОбщегоНазначения.СообщитьПользователю(
						СтрШаблон(
							НСтр("ru = 'Свойство ""%1"" поля ""%2"" должно иметь значение ""%3""'"),
							ИмяПоля,
							Реквизит.Синоним,
							ЗначениеПоля
						),,
						ПутьКЯчейке,, Отказ
					);
					
				Иначе
					
					ОбщегоНазначения.СообщитьПользователю(
						СтрШаблон(
							НСтр("ru = 'Свойство ""%1"" поля ""%2"" должно иметь значение ""%3""%4'"),
							ИмяПоля,
							Реквизит.Синоним,
							ЗначениеПоля
						),
						Объект, Реквизит.Имя,, Отказ
					);
				КонецЕсли;
					
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ПроверитьСоответствиеРеквизитаУстановленнымПараметрамВыбора()

Процедура ПроверитьСоответствиеОрганизацииПодразделения(Объект,
                                                        Отказ,
                                                        Знач ДополнительныеСвойства = Неопределено) Экспорт
	
	// При выполнении восстановления выполнять проверку не требуется делать
	
	Если ДополнительныеСвойства = Неопределено Тогда
		
		ДополнительныеСвойства = Объект.ДополнительныеСвойства;
		
	КонецЕсли;
	
	Если ПолучитьЗначениеПараметраСтруктуры(ДополнительныеСвойства, "ЭтоВосстановлениеПоследовательностей", Ложь) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если
		Не  ПраваИНастройкиПользователя.Значение("КонтролироватьСоответствиеОрганизацииПодразделения", Объект)
		Или Не ЕстьРеквизит(Объект, "ПодразделениеКомпании")
		Или Не ЕстьРеквизит(Объект, "Организация")
	Тогда 
			
		Возврат;
		
	КонецЕсли;
	
	Если
		ЗначениеЗаполнено(Объект.ПодразделениеКомпании)
		И ЗначениеЗаполнено(Объект.Организация)
		И Объект.ПодразделениеКомпании.Организация <> Объект.Организация
	Тогда
		
		ОбщегоНазначения.СообщитьПользователю(
			СтрШаблон(
				НСтр("ru = 'Подразделение ""%1"" не принадлежит организации ""%2""
						   |При необходимости отключите контроль соответствия организации и подразделения через право 41105'"),
				Объект.ПодразделениеКомпании,
				Объект.Организация),
			Объект,
			"Организация",
			,
			Отказ);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьКоличествоСерийнойНоменклатуры(Объект, Отказ) Экспорт
	
	// Нет смысла выполнять проверку, если учет по характеристикам не ведется
	Если НЕ ПолучитьФункциональнуюОпцию("ИспользоватьХарактеристики") Тогда
		Возврат;
	КонецЕсли;
	
	// Получим параметры текущего проверяемого объекта
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Объект.Ссылка));
	МенеджерОбъекта  = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
	
	// Последовательно обработаем каждую табличную часть объекта
	Для каждого ОбъектМетаданныхТаблицы Из ОбъектМетаданных.ТабличныеЧасти Цикл
		
		// Проверяем целесообразность проверки строк текущей таблицы
		Если НЕ ЕстьРеквизит(Объект, "Количество", ОбъектМетаданныхТаблицы.Имя) 
			ИЛИ НЕ ЕстьРеквизит(Объект, "Номенклатура", ОбъектМетаданныхТаблицы.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		// Определим какие вспомогательные реквизиты имеются в табличной части
		ЕстьКоличествоБазовое = ЕстьРеквизит(Объект, "КоличествоБазовое", ОбъектМетаданныхТаблицы.Имя);
		ЕстьКоэффициент       = ЕстьРеквизит(Объект, "Коэффициент",       ОбъектМетаданныхТаблицы.Имя);
		
		// Получаем таблицу признаков ведения учета для по товарам табличной части
		ТекстЗапроса =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Номенклатура.Ссылка КАК Номенклатура,
		|	ВЫБОР
		|		КОГДА Номенклатура.ТипНоменклатуры.ИспользованиеХарактеристик = 1
		|				ИЛИ Номенклатура.ТипНоменклатуры.ИспользованиеХарактеристик = 2
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ КАК УчетВедется,
		|	Номенклатура.ТипНоменклатуры.УникальностьСерийногоНомера КАК УникальностьСерийногоНомера
		|ИЗ
		|	Справочник.Номенклатура КАК Номенклатура
		|ГДЕ
		|	Номенклатура.Ссылка В(&СписокНоменклатуры)";
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("СписокНоменклатуры", Объект[ОбъектМетаданныхТаблицы.Имя].ВыгрузитьКолонку("Номенклатура"));
		ПараметрыУчета = Запрос.Выполнить().Выгрузить();
		
		// Проверяем целесообразность дальнейших действий
		Если ПараметрыУчета.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		// Выполняем проверку корректности заполнения
		Для каждого СтрокаТабличнойЧасти Из Объект[ОбъектМетаданныхТаблицы.Имя] Цикл
			
			// Получим количество товара в базовой единице измерения 
			КоличествоРасчетное = ?(ЕстьКоэффициент, СтрокаТабличнойЧасти.Количество * СтрокаТабличнойЧасти.Коэффициент, СтрокаТабличнойЧасти.Количество); 
			КоличествоТовара = ?(ЕстьКоличествоБазовое, СтрокаТабличнойЧасти.КоличествоБазовое, КоличествоРасчетное);
			
			// Проверка имеет смысл для строк у которых количество не единичное
			Если КоличествоТовара <= 1 Тогда
				Продолжить;
			КонецЕсли;
			
			// Проверять нужно только те строки, у которых заполнена номенклатура и характеристика.
			Если НЕ ЗначениеЗаполнено(СтрокаТабличнойЧасти.Номенклатура) Тогда
				Продолжить;
			КонецЕсли;
			
			// Получим параметры ведения учета по текущей номенклатуре
			ПараметрыУчетаНоменклатуры = ПараметрыУчета.Найти(СтрокаТабличнойЧасти.Номенклатура, "Номенклатура");
			
			// Проверим и сообщим пользователю, если что-то не так
			Если ЗначениеЗаполнено(ПараметрыУчетаНоменклатуры) И ПараметрыУчетаНоменклатуры.УчетВедется 
					И ПараметрыУчетаНоменклатуры.УникальностьСерийногоНомера Тогда
				ОбщегоНазначения.СообщитьПользователю(
					СтрШаблон(
						НСтр("ru = 'Номенклатура ""%1"" учитывается по уникальным серийным номерам. Количество не может превышать 1 базовую единицу.'"),
						СтрокаТабличнойЧасти.Номенклатура
					),
					Объект,
					ОбъектМетаданныхТаблицы.Имя + "[" + (СтрокаТабличнойЧасти.НомерСтроки - 1) + "]" + ".Номенклатура",
					,
					Отказ
				);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ПроверитьКоличествоСерийнойНоменклатуры()

// Возвращает признак обработки события в упрощенном режиме, когда проверка корректности не производиться.
//
// Параметры:
//  Объект - Объект, для которого выполняется обработка события.
//
Функция РежимУпрощеннойЗагрузкиОбъекта(Объект) Экспорт
	
	Возврат ПолучитьЗначениеПараметраСтруктуры(Объект.ДополнительныеСвойства, "Загрузка", Объект.ОбменДанными.Загрузка);
	
КонецФункции // РежимУпрощеннойЗагрузкиОбъекта()

// Производит проверку использования переданной Ссылки в указанной таблице информационной базы.
//
// Параметры:
//  Ссылка     - Ссылка - Ссылка на объект для которого необходимо провести проверку
//  ИмяОбъекта - Строка - Объект метаданных в котором необходимо провести проверку
//  ИмяПоля    - Строка - Поле по которому необходимо провести проверку.
//
Функция ПроверитьИспользованиеСсылки(Ссылка, ИмяОбъекта, ИмяПоля) Экспорт
	
	МассивЗначений = Новый Массив();
	
	// Передано несколько ссылок для проверки
	Если ТипЗнч(Ссылка) = Тип("Массив") Тогда
		МассивЗначений.Добавить(Ссылка);
	ИначеЕсли НЕ ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекстЗапроса =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1 
	|	Таблица." + ИмяПоля + "
	|ИЗ
	|	" + ИмяОбъекта + " КАК Таблица
	|ГДЕ
	|	Таблица." + ИмяПоля + " В (&Значение)";
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Значение", ?(МассивЗначений.Количество() > 0, МассивЗначений, Ссылка));
	
	Возврат (НЕ Запрос.Выполнить().Пустой());
	
КонецФункции // ПроверитьИспользованиеСсылки()

// Функция проверяет используется ли объект как значение константы
//
// Параметры:
//  Ссылка       - Ссылка - Ссылка на объект для которого необходимо провести проверку
//  ИмяКонстанты - Строка - Необязательный "возвратный" параметр, в котором возвращается имя найденной константы.
//
// Возвращаемое значение:
//  Булево - ЛОЖЬ если на объект не указывает ни одна из констант, ИСТИНА если есть константа,
//           которая ссылается на Объект (при этом имя константы можно получить из ИмяКонстанты).
//
Функция ПроверитьИспользованиеСсылкиВКонстантах(Ссылка, ИмяКонстанты = "") Экспорт
	
	Если НЕ ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	ПроверяемыеКонстанты = КонстантыСодержащиеТип(ТипЗнч(Ссылка));
	
	Если НЕ ЗначениеЗаполнено(ПроверяемыеКонстанты) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Разделитель =
	"
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	Шаблон =
	"ВЫБРАТЬ
	|	%1.Значение КАК Значение,
	|	""%1"" КАК ИмяКонстанты
	|ИЗ
	|	Константа.%1 КАК %1
	|ГДЕ
	|	%1.Значение = &Значение";
	
	ЧастиЗапроса = Новый Массив;
	
	Для Каждого Константа Из ПроверяемыеКонстанты Цикл
		
		ЧастиЗапроса.Добавить(СтрШаблон(Шаблон, Константа));
		
	КонецЦикла;
	
	Запрос = Новый Запрос(СтрСоединить(ЧастиЗапроса, Разделитель));
	Запрос.УстановитьПараметр("Значение", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	ИмяКонстанты = Константы[Выборка.ИмяКонстанты].СоздатьМенеджерЗначения().Метаданные().Синоним;
	Возврат Истина;
	
КонецФункции // ПроверитьИспользованиеСсылкиВКонстантах()

// Функция применяется для получения уточненного значения реквизита объекта или строки из параметров действия.
//
Функция ПолучитьЗначениеРеквизита(ИмяПоля, Объект, ПараметрыДействия) Экспорт
	
	Результат = Неопределено;
	
	Если ПараметрыДействия.Свойство(ИмяПоля) Тогда
		Результат = ПараметрыДействия[ИмяПоля];
	ИначеЕсли ЕстьРеквизит(Объект, ИмяПоля) Тогда
		Результат = Объект[ИмяПоля];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьЗначениеРеквизита()

Функция КонстантыСодержащиеТип(Тип)
	
	СоставКонстант = Новый Массив;
	
	Для Каждого Константа Из Метаданные.Константы Цикл
		
		Если Константа.Тип.СодержитТип(Тип) Тогда
			
			СоставКонстант.Добавить(Константа.Имя);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СоставКонстант;
	
КонецФункции

Процедура ПолучитьСинонимРеквизита(Реквизит, ИмяПоля)
	
	МассивТипов = Реквизит.Тип.Типы();
	Для Каждого Тип Из МассивТипов Цикл
		МетаданныеОбъекта = Метаданные.НайтиПоТипу(Тип);
		Для Каждого РеквизитОбъекта Из МетаданныеОбъекта.Реквизиты Цикл
			
			Если РеквизитОбъекта.Имя = ИмяПоля И ЗначениеЗаполнено(РеквизитОбъекта.Синоним) Тогда
				ИмяПоля = РеквизитОбъекта.Синоним;
				Возврат;          
			КонецЕсли;			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти