

#Область ПрограммныйИнтерфейс

// Определяет в зависимости от положения шкалы времени на планировщике
//
// Параметры:
//  КалендарьДневной - ТабличныйДокумент - Табличный документ планировщика.
//  ПоложениеШкалы	 - Строка			 - Настройка положения шкалы. "ЛЕВО" или "ВЕРХ".
//  Ресурс			 - Число			 - Номер необходимого ресурса.
//  Первая			 - Число			 - Номер первой ячейки области
//  Последняя		 - Число			 - Номер последней ячейки области. Если не указана берется значение первой ячейки.
// 
// Возвращаемое значение:
//  ОбластьЯчеекТабличногоДокумента - Область табличного документа.
//
Функция Область(КалендарьДневной, ПоложениеШкалы, Ресурс, Первая, Знач Последняя = Неопределено) Экспорт
	
	Если Последняя = Неопределено Тогда
		Последняя = Первая;
	КонецЕсли;
	
	Если ПоложениеШкалы = "ЛЕВО" Тогда
		
		Возврат КалендарьДневной.Область(Ресурс, Первая, Ресурс, Последняя);
		
	КонецЕсли;
	
	Возврат КалендарьДневной.Область(Первая, Ресурс, Последняя, Ресурс);
	
КонецФункции

// Определяет первый и последний номер ячейки шкалы времени у выделенной области
//
// Параметры:
//  КалендарьДневной	- ТабличныйДокумент					- Табличный документ в котором выделена область.
//  ПоложениеШкалы		- Строка							- Настройка режима расположения шкалы времени.
//  Область				- ОбластьЯчеекТабличногоДокумента	- Текущая выделенная область.
//
// Возвращаемое значение:
//  Структура - Ключи "Первая,Последняя".
//
Функция ВременныеРамкиОбласти(КалендарьДневной, ПоложениеШкалы, Знач Область = Неопределено) Экспорт
	
	Рез = Новый Структура;
	Если Область = Неопределено Тогда
		Область = КалендарьДневной.ТекущаяОбласть;
	КонецЕсли;
	
	Если ПоложениеШкалы = "ЛЕВО" Тогда
		Рез.Вставить("Первая", Область.Лево);
		Рез.Вставить("Последняя", Область.Право);
	Иначе
		Рез.Вставить("Первая", Область.Верх);
		Рез.Вставить("Последняя", Область.Низ);
	КонецЕсли;
	
	Возврат Рез;
	
КонецФункции // ВременныеРамкиОбласти()

// Функция - Получить представление времени
//
// Параметры:
//  Продолжительность	 - Число - Время в секундах
// 
// Возвращаемое значение:
//  Строка - Представление времени.
//
Функция ПолучитьПредставлениеВремени(Продолжительность)  Экспорт
	// Представление числа
	ЧастиПредставления = Новый Массив;
	
	Часы = Цел(Продолжительность / 3600);
	Если Часы <> 0 Тогда
		ЧастиПредставления.Добавить(СтрШаблон("%1 ч.", Часы));
	КонецЕсли;
	
	Минуты = Цел((Продолжительность - Часы * 3600) / 60);
	
	Если Часы = 0 И Минуты = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ЧастиПредставления.Добавить(СтрШаблон("%1 мин.", Минуты));
	
	Возврат СтрСоединить(ЧастиПредставления, " ");
	
КонецФункции

// Формирует дерево объектов планирования
//
// Параметры:
//  Объект    - ДанныеФормыСтруктура, ДокументОбъект - Объект документа для которого формируются объекты
//  Интервалы - ТаблицаЗначений                      - Данные интервалов планирования документа
//  Объекты   - ДеревоЗначений                       - Дерево с объектами
//
Процедура ЗаполнитьОбъектыПланирования(Объект, Интервалы, Объекты) Экспорт
	Перем ПланируютсяПоАвтоработам;
	Элементы = Объекты.ПолучитьЭлементы();
	
	Если Элементы.Количество() > 0 Тогда // запомним идентификаторы планирующихся по автоработам причин
		ПланируютсяПоАвтоработам = Новый Массив;
		Для Каждого Элемент Из Элементы Цикл
			Если Элемент.ЭтоПричина И НЕ Элемент.ПланированиеПоГруппе Тогда
				ПланируютсяПоАвтоработам.Добавить(Элемент.Идентификатор);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Элементы.Очистить();
	
	ЕстьПричины = ?(Объект.ПричиныОбращения.Количество() > 0, Истина, Ложь);
	
	МассивЭлементов = ПланированиеРесурсовВызовСервера.ПолучитьПорядокЭлементов(ПодготовитьМассивЭлементовДляСохраненияПорядка(Объект));  
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		// Заполним причины и автоработы
		Если Элемент.ТипЭлемента = 1 И ЕстьПричины Тогда
			// Получим причину
			//@skip-check unknown-method-property
			Причина = Объект.ПричиныОбращения.НайтиПоИдентификатору(Элемент.ИдентификаторСтроки);
			// Создадим объект дерева
			НовыйОбъектПричины = Элементы.Добавить();
			// Заполняем данные причины
			НовыйОбъектПричины.Идентификатор = Причина.ИдентификаторПричиныОбращения;
			НовыйОбъектПричины.Представление = Причина.ПричинаОбращенияСодержание;
			НовыйОбъектПричины.ЭтоПричина    = Истина;
			НовыйОбъектПричины.ЭтоГруппа     = Истина;
			
			УсловиеИнтерваловПричины = Новый Структура("Идентификатор", НовыйОбъектПричины.Идентификатор);
			УсловиеИнтерваловГруппы  = Новый Структура("ИдентификаторГруппы", НовыйОбъектПричины.Идентификатор);
			
			ИнтерваловПричины = Интервалы.НайтиСтроки(УсловиеИнтерваловПричины);
			ИнтерваловГруппы  = Интервалы.НайтиСтроки(УсловиеИнтерваловГруппы);
			
			Если ПланируютсяПоАвтоработам <> Неопределено И ПланируютсяПоАвтоработам.Найти(НовыйОбъектПричины.Идентификатор) <> Неопределено Тогда
				НовыйОбъектПричины.ПланированиеПоГруппе = Ложь;
			Иначе
				НовыйОбъектПричины.ПланированиеПоГруппе = (ИнтерваловГруппы.Количество() = 0);
			КонецЕсли;
			
			// Посчитаем норму времени причины
			Если НовыйОбъектПричины.ПланированиеПоГруппе Тогда
				НормаВремени = ИтогЗначениеВМассивеСтрок(ИнтерваловПричины);
				
				НовыйОбъектПричины.Картинка = КартинкаПричиныОбращенияСГруппой();
			Иначе
				НормаВремени = ИтогЗначениеВМассивеСтрок(ИнтерваловГруппы);
				
				НовыйОбъектПричины.Картинка = КартинкаПричиныОбращения();
			КонецЕсли;
			
			// фактическое время
			НовыйОбъектПричины.НормаВремени = НормаВремени;
			НовыйОбъектПричины.НормаВремениПредставление = ПолучитьПредставлениеВремени(НовыйОбъектПричины.НормаВремени);
			
			НормаВремениПричиныПоАвтоработамПлан = 0;
			
			ЭлементыПричины = НовыйОбъектПричины.ПолучитьЭлементы();
			
			КоличествоДобавленных = 0;
			Для Каждого ЭлементАвторабота Из МассивЭлементов Цикл
				// Проверим автоработу и ее подчиненность причине
				Если ЭлементАвторабота.ТипЭлемента <> 2 ИЛИ ЭлементАвторабота.ИдентификаторПричиныОбращения <> Причина.ИдентификаторПричиныОбращения Тогда
					Продолжить;
				КонецЕсли;
				// Получим автоработу
				//@skip-check unknown-method-property
				Авторабота = Объект.Автоработы.НайтиПоИдентификатору(ЭлементАвторабота.ИдентификаторСтроки);
				// Создадим элемент дерева
				НовыйОбъектАвтоработы = ЭлементыПричины.Добавить();
				// Заполним
				НовыйОбъектАвтоработы.Идентификатор        = Авторабота.ИдентификаторРаботы;
				НовыйОбъектАвтоработы.Представление        = Авторабота.Авторабота;
				НовыйОбъектАвтоработы.Картинка             = КартинкаАвтоработы();
				НовыйОбъектАвтоработы.ПланированиеПоГруппе = НовыйОбъектПричины.ПланированиеПоГруппе;
				НовыйОбъектАвтоработы.НормаВремениПлан     = Авторабота.Количество * Авторабота.Коэффициент * 3600;
				НовыйОбъектАвтоработы.НормаВремениПланПредставление     = ПолучитьПредставлениеВремени(НовыйОбъектАвтоработы.НормаВремениПлан);
				
				НормаВремениПричиныПоАвтоработамПлан = НормаВремениПричиныПоАвтоработамПлан + НовыйОбъектАвтоработы.НормаВремениПлан;
				
				Если НЕ НовыйОбъектАвтоработы.ПланированиеПоГруппе Тогда
					НовыйОбъектАвтоработы.НормаВремени = ИтогЗначениеВМассивеСтрок(
					Интервалы.НайтиСтроки(Новый Структура("Идентификатор", НовыйОбъектАвтоработы.Идентификатор)));
					НовыйОбъектАвтоработы.НормаВремениПредставление = ПолучитьПредставлениеВремени(НовыйОбъектАвтоработы.НормаВремени);
				КонецЕсли;
				КоличествоДобавленных = КоличествоДобавленных + 1;
			КонецЦикла;
			
			Если КоличествоДобавленных = 0 Тогда
				НормаВремениПричиныПоАвтоработамПлан = Причина.НормаВремени;
			КонецЕсли;
			
			// запланированное время
			НовыйОбъектПричины.НормаВремениПлан = НормаВремениПричиныПоАвтоработамПлан;
			НовыйОбъектПричины.НормаВремениПланПредставление = ПолучитьПредставлениеВремени(НовыйОбъектПричины.НормаВремениПлан);
			
			// Если нет причин, тогда заполним атвоработы
		ИначеЕсли Элемент.ТипЭлемента = 2 И Не ЕстьПричины Тогда
			
			//@skip-check unknown-method-property
			Авторабота = Объект.Автоработы.НайтиПоИдентификатору(Элемент.ИдентификаторСтроки);
			НовыйОбъектАвтоработы = Элементы.Добавить();
			
			НовыйОбъектАвтоработы.Идентификатор = Авторабота.ИдентификаторРаботы;
			НовыйОбъектАвтоработы.Представление = Авторабота.Авторабота;
			НовыйОбъектАвтоработы.ЭтоГруппа     = Истина;
			НовыйОбъектАвтоработы.Картинка      = КартинкаАвтоработы();
			
			НовыйОбъектАвтоработы.НормаВремени = ИтогЗначениеВМассивеСтрок(
				Интервалы.НайтиСтроки(Новый Структура("Идентификатор", НовыйОбъектАвтоработы.Идентификатор)));
			НовыйОбъектАвтоработы.НормаВремениПредставление = ПолучитьПредставлениеВремени(НовыйОбъектАвтоработы.НормаВремени);
			
			НовыйОбъектАвтоработы.НормаВремениПлан = Авторабота.Коэффициент * Авторабота.Количество * 3600;
			НовыйОбъектАвтоработы.НормаВремениПланПредставление = ПолучитьПредставлениеВремени(НовыйОбъектАвтоработы.НормаВремениПлан);
			
			// добавим вспомогательные работы
		ИначеЕсли Элемент.ТипЭлемента = 3 Тогда
			
			//@skip-check unknown-method-property
			Авторабота = Объект.ВспомогательныеАвтоработы.НайтиПоИдентификатору(Элемент.ИдентификаторСтроки);
			НовыйОбъектАвтоработы = Элементы.Добавить();
			
			НовыйОбъектАвтоработы.Идентификатор = Авторабота.ИдентификаторРаботы;
			НовыйОбъектАвтоработы.Представление = Авторабота.Авторабота;
			НовыйОбъектАвтоработы.ЭтоГруппа     = Истина;
			НовыйОбъектАвтоработы.Картинка      = КартинкаАвтоработы();
			
			НовыйОбъектАвтоработы.ЭтоВспомогательнаяАвторабота = Истина;
			
			// фактическое время
			НовыйОбъектАвтоработы.НормаВремени = ИтогЗначениеВМассивеСтрок(
			Интервалы.НайтиСтроки(Новый Структура("Идентификатор", НовыйОбъектАвтоработы.Идентификатор)));
			НовыйОбъектАвтоработы.НормаВремениПредставление = ПолучитьПредставлениеВремени(НовыйОбъектАвтоработы.НормаВремени);
			
			// запланированное время
			НовыйОбъектАвтоработы.НормаВремениПлан = Авторабота.НормаВремени * 3600;
			НовыйОбъектАвтоработы.НормаВремениПланПредставление = ПолучитьПредставлениеВремени(НовыйОбъектАвтоработы.НормаВремениПлан);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Заполнение данных из объекта планирования
//
// Параметры:
//  Объекты - ДеревоЗначений - Дерево с объектами.
//  Интервал - СтрокаТаблицыЗначений - Данные интервала планирования документа.
//  ОбъектПланирования - СтрокаДереваЗначений - Объект планирования, для которого выполняется обработка.
//
Процедура УстановитьИдентификаторыНовогоИнтервала(Объекты, Интервал, ОбъектПланирования) Экспорт
	
	Если НЕ ПустаяСтрока(Интервал.Идентификатор) Тогда
		Возврат;
	КонецЕсли;
	
	Интервал.Идентификатор = ОбъектПланирования.Идентификатор;
	Если НЕ ОбъектПланирования.ЭтоГруппа Тогда
		Интервал.ИдентификаторГруппы = ОбъектПланирования.ПолучитьРодителя().Идентификатор;
	КонецЕсли;
	
	Если ОбъектПланирования.ЭтоПричина Тогда
		Интервал.ВидОбъектаПланирования = ПредопределенноеЗначение("Перечисление.ВидыОбъектовПланированияРесурсов.ПричинаОбращения");
	ИначеЕсли ОбъектПланирования.ЭтоВспомогательнаяАвторабота Тогда
		Интервал.ВидОбъектаПланирования = ПредопределенноеЗначение("Перечисление.ВидыОбъектовПланированияРесурсов.ВспомогательнаяАвторабота");
	Иначе
		Интервал.ВидОбъектаПланирования = ПредопределенноеЗначение("Перечисление.ВидыОбъектовПланированияРесурсов.Авторабота");
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Обновить индикатор нормы времени объекта
//
// Параметры:
//  ОбъектПланирования	- СтрокаДереваЗначений	- Объект планирования, для которого выполняется обновление
//  Интервалы			- ТаблицаЗначени		- Данные интервалов планирования документа
//  ОбновлятьРодителя	-Булево					- Признак выполнения обновления нормы времени для родителя.
//
Процедура ОбновитьИндикаторНормыВремениОбъекта(ОбъектПланирования, Интервалы, ОбновлятьРодителя = Истина) Экспорт
	
	Если ОбъектПланирования.ЭтоПричина И НЕ ОбъектПланирования.ПланированиеПоГруппе Тогда
		Условие = Новый Структура("ИдентификаторГруппы", ОбъектПланирования.Идентификатор);
	Иначе
		Условие = Новый Структура("Идентификатор", ОбъектПланирования.Идентификатор);
	КонецЕсли;
	
	ДанныеРасчета = Интервалы.НайтиСтроки(Условие);
	
	ОбъектПланирования.НормаВремени = ИтогЗначениеВМассивеСтрок(ДанныеРасчета);
	
	ОбъектПланирования.НормаВремениПредставление = ПолучитьПредставлениеВремени(ОбъектПланирования.НормаВремени);
	
	Если НЕ ОбъектПланирования.ЭтоГруппа И ОбновлятьРодителя Тогда
		ОбновитьИндикаторНормыВремениОбъекта(ОбъектПланирования.ПолучитьРодителя(), Интервалы);
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Рассчитать продолжительность
//
// Параметры:
//  Интервал - СтрокаТаблицыЗначений - Данные интервала планирования документа
//
Процедура РассчитатьПродолжительность(Интервал) Экспорт
	
	Если ЗначениеЗаполнено(Интервал.Начало) И ЗначениеЗаполнено(Интервал.Конец) И Интервал.Конец > Интервал.Начало Тогда
		Интервал.НормаВремени = (Интервал.Конец - Интервал.Начало);
		Интервал.НормаВремениПредставление = ПолучитьПредставлениеВремени(Интервал.НормаВремени);
		Иначе
		Интервал.НормаВремени = 0;
		Интервал.НормаВремениПредставление = "";
	КонецЕсли;
	
КонецПроцедуры

// Проверка наличия объекта к которуму относится интервал среди объектов документа
//
// Параметры:
//  Интервал    - СтрокаТаблицыЗначений - Строка из таблицы интервалов
//  Объект      - ДокументОбъект        - Документ для которого идет проверка наличия объектов планирования
//  ДляУдаления - Массив                - Коллекция строк с интервалами для которых не нашлось объекта планирования в документе
//
Процедура ПроверитьДоступностьИнтервала(Интервал, Объект, ДляУдаления) Экспорт
	
	СоставПричинОбращения = Неопределено;
	Попытка
		СоставПричинОбращения = ПолучитьЗначениеПараметраСтруктуры(Объект.ДополнительныеСвойства, "СоставПричинОбращения");
	Исключение 
		СоставПричинОбращения = Неопределено;	
	КонецПопытки;
	
	#Если НЕ Клиент Тогда
		
		ЗаполнятьПредставление = ЕстьРеквизит(Интервал, "ПредставлениеОбъекта");
		
	#Иначе
		
		ЗаполнятьПредставление = ЕстьРеквизитНаКлиенте(Интервал, "ПредставлениеОбъекта");
		
	#КонецЕсли
	
	Если Интервал.ВидОбъектаПланирования = ПредопределенноеЗначение("Перечисление.ВидыОбъектовПланированияРесурсов.Авторабота") Тогда
		
		Условие = Новый Структура("ИдентификаторРаботы", Интервал.Идентификатор);
		Объекты = Объект.Автоработы.НайтиСтроки(Условие);
		
		Если Объекты.Количество() > 0 Тогда
			
			Интервал.Объект = Объекты[0].Авторабота;
			
			Если ЗаполнятьПредставление Тогда
				
				Интервал.ПредставлениеОбъекта = Строка(Интервал.Объект);
				
			КонецЕсли;
			
			Если СоставПричинОбращения = Неопределено Тогда
				
				Интервал.ИдентификаторГруппы = Объекты[0].ИдентификаторПричиныОбращения;
				
			Иначе
				
				Если СоставПричинОбращения.Колонки.Найти("ИдентификаторАвтоработы") <> Неопределено Тогда
					
					Условие = Новый Структура("ИдентификаторАвтоработы", Интервал.Идентификатор);
					
				Иначе
					
					Условие = Новый Структура("Авторабота", Интервал.Идентификатор);
					
				КонецЕсли;
				
				НайденныеПричины = СоставПричинОбращения.НайтиСтроки(Условие);
				
				Если НайденныеПричины.Количество() > 0 Тогда
					
					Если СоставПричинОбращения.Колонки.Найти("ИдентификаторПричиныОбращения") <> Неопределено Тогда
						
						Интервал.ИдентификаторГруппы = НайденныеПричины[0].ИдентификаторПричиныОбращения;
						
					Иначе
						
						Интервал.ИдентификаторГруппы = НайденныеПричины[0].ПричинаОбращения;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			ДляУдаления.Добавить(Интервал);
			
		КонецЕсли;
		
	ИначеЕсли Интервал.ВидОбъектаПланирования = ПредопределенноеЗначение("Перечисление.ВидыОбъектовПланированияРесурсов.ВспомогательнаяАвторабота") Тогда
		
		Условие = Новый Структура("ИдентификаторРаботы", Интервал.Идентификатор);
		Объекты = Объект.ВспомогательныеАвтоработы.НайтиСтроки(Условие);
		
		Если Объекты.Количество() > 0 Тогда
			
			Интервал.Объект = Объекты[0].Авторабота;
			
			Если ЗаполнятьПредставление Тогда
				
				Интервал.ПредставлениеОбъекта = Строка(Интервал.Объект);
				
			КонецЕсли;
			
		Иначе
			
			ДляУдаления.Добавить(Интервал);
			
		КонецЕсли;
		
	Иначе
		
		Условие = Новый Структура("ИдентификаторПричиныОбращения", Интервал.Идентификатор);
		Объекты = Объект.ПричиныОбращения.НайтиСтроки(Условие);
		
		Если Объекты.Количество() > 0 Тогда
			
			Интервал.Объект = Объекты[0].ПричинаОбращения;
			
			Если ЗаполнятьПредставление Тогда
				
				Интервал.ПредставлениеОбъекта = Объекты[0].ПричинаОбращенияСодержание;
				
			КонецЕсли;
			
		Иначе
			
			ДляУдаления.Добавить(Интервал);
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск строк в дереве подхлдящих по условию
//
// Параметры:
//  Дерево    - ДеревоЗначений - Дерево для поиска
//  Условия   - Структура      - Структура с условиями, где ключ это имя поля в строке дерева,
//                               а значение - значение которому должно соответствовать значение в поле строки дерева
//  Результат - Массив         - Строки дерева подходящие под условие, используется для рекурсивных вызовов
// 
// Возвращаемое значение:
//  Массив - Коллекция строк подходящих под условие
//
Функция НайтиВДеревеОбъектов(Дерево, Условия, Результат = Неопределено) Экспорт
	
	Если Результат = Неопределено Тогда
		Результат = Новый Массив;
	КонецЕсли;
	
	Для Каждого Ветка Из Дерево.ПолучитьЭлементы() Цикл
		ПодходитПоУсловию = Истина;
		Для Каждого Условие Из Условия Цикл
			ПодходитПоУсловию = ПодходитПоУсловию И (Ветка[Условие.Ключ] = Условие.Значение);
		КонецЦикла;
		
		Если ПодходитПоУсловию Тогда
			Результат.Добавить(Ветка);
		КонецЕсли;
		
		НайтиВДеревеОбъектов(Ветка, Условия, Результат);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Отображаем интервал на календаре
//
// Параметры:
//  Рисунки				  - ОбластьЯчеекТабличногоДокумента - Область табличного документа.
//  Идентификатор		  - Строка - Идентификатор нового интервала
//  ИдентификаторОбъекта  - Строка - Идентификатор объекта текущих данных
//  Представление		  - Строка - Строковое представление интервала
//  ЭтоВыделенныйИнтервал - Булево - Признак выделения цветом интервала
//  ОбластьИнтервала	  - ОбластьЯчеекТабличногоДокумента - Область табличного документа
//
Процедура РасположитьИнтервалНаКалендаре(Рисунки,
                                         Идентификатор,
                                         ИдентификаторОбъекта,
                                         Представление,
                                         ЭтоВыделенныйИнтервал,
                                         ОбластьИнтервала) Экспорт
	
	НовыйРисунок = Рисунки.Добавить(ТипРисункаТабличногоДокумента.Текст);
	НовыйРисунок.Линия = Новый Линия(ТипЛинииРисункаТабличногоДокумента.Сплошная, 1);
	НовыйРисунок.ГиперСсылка = Истина;
	НовыйРисунок.РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Обрезать;
	
	НовыйРисунок.ВертикальноеПоложение = ВертикальноеПоложение.Центр;
	
	#Если Клиент Тогда
	
		НовыйРисунок.Шрифт = ОбщегоНазначенияКлиент.ШрифтСтиля("ЗаписьНаРемонтШрифтГрафика");
		
	#Иначе
		
		НовыйРисунок.Шрифт = ШрифтыСтиля.ЗаписьНаРемонтШрифтГрафика;
		
	#КонецЕсли
	
	Если ЭтоВыделенныйИнтервал Тогда
		
		#Если Клиент Тогда
	
			НовыйРисунок.ЦветФона = ОбщегоНазначенияКлиент.ЦветСтиля("ЗаписьНаРемонтТекущийИнтервал");
			
		#Иначе
			
			НовыйРисунок.ЦветФона = ЦветаСтиля.ЗаписьНаРемонтТекущийИнтервал;
			
		#КонецЕсли
		
	Иначе
		
		#Если Клиент Тогда
	
			НовыйРисунок.ЦветФона = ОбщегоНазначенияКлиент.ЦветСтиля("ЗаписьНаРемонтТекущийДокумент");
			
		#Иначе
			
			НовыйРисунок.ЦветФона = ЦветаСтиля.ЗаписьНаРемонтТекущийДокумент;
			
		#КонецЕсли
		
	КонецЕсли;
	
	НовыйРисунок.Текст = Представление;
	
	данныеРасшифровки = Новый Массив;
	данныеРасшифровки.Добавить(Идентификатор);
	данныеРасшифровки.Добавить(НовыйРисунок.Имя);
	данныеРасшифровки.Добавить(ИдентификаторОбъекта);
	данныеРасшифровки.Добавить(Представление);
	
	НовыйРисунок.Расшифровка = РасшифровкаТекущегоИнтервала(данныеРасшифровки);
	
	НовыйРисунок.Расположить(ОбластьИнтервала);
	
КонецПроцедуры

// Функция - Проверить доступность интервала планирования
//
// Параметры:
//  ДатаОкончанияИнтервала	- Дата		- Дата завершения интервала
//  КоличествоДней			- Число		- Количество прошедших дней, в которые возможно планирование.
//  ВыводитьСообщение		- Булево	- Признак того, что будет выведено сообщение о недоступности интервала.
// 
// Возвращаемое значение:
//  Булево - признак доступности интервала.
//
Функция ПроверитьДоступностьВремениИнтервалаПланирования(ДатаОкончанияИнтервала,
		КоличествоДней,
		ВыводитьСообщение = Ложь) Экспорт
	Если ДатаОкончанияИнтервала <= НачалоДня(ТекущаяДата() - КоличествоДней * 24 * 60 * 60) Тогда
		Если ВыводитьСообщение Тогда
			#Если Клиент Тогда
			ОбщегоНазначенияКлиент.СообщитьПользователю(НСтр("ru = 'Недопустимые интервалы времени работы'"));
			#Иначе
			ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Недопустимые интервалы времени работы'"));
			#КонецЕсли

		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Процедура - Удалить интервалы
//
// Параметры:
//  СтрокиДляУдаления		 - Массив				 - Массив идентификаторов строк
//  ПланированиеИнтервалы	 - ДанныеФормыКоллекция	 - Таблица откуда будем удалять
//  Отказ					 - Булево				 - Отказ.
//
Процедура УдалитьИнтервалы(СтрокиДляУдаления, ПланированиеИнтервалы, Отказ = Ложь) Экспорт
	Отказ = Истина;
	МассивДляУдаления = Новый Массив;
	Для Каждого ИдентификаторСтроки Из СтрокиДляУдаления Цикл
		СтрокаТаблицы = ПланированиеИнтервалы.НайтиПоИдентификатору(ИдентификаторСтроки);
		Если СтрокаТаблицы <> Неопределено И Не СтрокаТаблицы.НеДоступностьИнтервала Тогда
			МассивДляУдаления.Добавить(СтрокаТаблицы);
		КонецЕсли;
	КонецЦикла;
	Для Каждого СтрокаДляУдаления Из МассивДляУдаления Цикл
		ПланированиеИнтервалы.Удалить(СтрокаДляУдаления);
	КонецЦикла;
КонецПроцедуры

// Получить временные рамки
//  возвращает даты начало самого раннего интервала и конец самого позднего интервала.
//
// Параметры:
//  ПланированиеИнтервалы - ТаблицаЗначений - запланированные интервалы работ;
//      *ДатаНачала       - Дата            - начало самого раннего интервала;
//      *ДатаОкончания    - Дата            - конец самого позднего интервала.
// 
// Возвращаемое значение:
//  Структура - Дата начала и дата окончания интервала.
//
Функция ПолучитьВременныеРамки(Знач ПланированиеИнтервалы) Экспорт
	
	Если ПланированиеИнтервалы.Количество() > 0 Тогда
		
		Начало = ПланированиеИнтервалы[0].Начало;
		Конец  = ПланированиеИнтервалы[0].Конец;
		
		Для Каждого Интервал Из ПланированиеИнтервалы Цикл
			
			Начало = Мин(Интервал.Начало, Начало);
			Конец  = Макс(Интервал.Конец, Конец);
			
		КонецЦикла;
		
		Возврат Новый Структура("Начало,Конец", Начало, Конец);
		
	КонецЕсли;
	
	Возврат Новый Структура("Начало,Конец", Дата(1, 1, 1), Дата(1, 1, 1));
	
КонецФункции

// Устанокка доп. параметров отображения поля планировщика.
//
// Параметры:
//  Планировщик  - Планировщик - Объект планировщика в форме.
//
Процедура ДополнительныеНастройкиПоляПланировщика(Планировщик) Экспорт
	
	Планировщик.ШкалаВремени.Положение = ПоложениеШкалыВремени.Верх;
	Планировщик.ВыравниватьГраницыЭлементовПоШкалеВремени   = Истина;
	Планировщик.ОтображатьПеренесенныеЗаголовкиШкалыВремени = Истина;
	Планировщик.ОтображатьПеренесенныеЗаголовки             = Ложь;
	Планировщик.ОтображатьТекущуюДату                       = Ложь;
	
КонецПроцедуры // ДополнительныеНастройкиПоляПланировщика()

// Устанавливает настройки фиксации дневного календаря.
//
// Параметры:
//  Форма - УправляемаяФорма - Форма содержащая календарь, должна содержать реквизиты:
//                             КалендарьДневной - Табличный документ календаря,
//                             РасположениеРесурсов - Настройка расположения ресурсов строкой,
//                             ИнтервалыОтображения - Масмив отображаемых интервалов.
//
Процедура УстановитьФиксациюПланировщика(Форма) Экспорт
	
	Если Форма.РасположениеРесурсов <> "ВЕРХ" Тогда
		
		Форма.КалендарьДневной.ФиксацияСлева = 1;
		Форма.КалендарьДневной.ФиксацияСверху = ?(Форма.ИнтервалыОтображения.Количество() > 1, 5, 4);
		
	Иначе
		
		Форма.КалендарьДневной.ФиксацияСлева = 3;
		Форма.КалендарьДневной.ФиксацияСверху = 1;
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьФиксациюПланировщика()

// Рассчитывает дату окончания интервала в зависимости от режима календаря.
//
// Параметры:
//  Дата - Дата - Начало интервала.
//  Режим - Строка - Режим календаря. Доступные значения "День", "2Дня".
//
// Возвращаемое значение:
//  Дата - Конец интервала.
//
Функция ДатаОкончанияИнтервала(Дата, Режим) Экспорт
	
	Возврат ?(Режим = "День", КонецДня(Дата), КонецДня(КонецДня(Дата) + 1));
	
КонецФункции

// Проверяет что интервал входит в отображаемые облаасти на планировщике.
//
// Параметры:
//  Начало - Дата - Начало проверяемого интервала.
//  Конец - Дата - Конец проверяемого интервала.
//  ОтображаемыеИнтервалы - Массив - Области отображаемые на календаре.
//
// Возвращаемое значение:
//  Булево - Истина интервал входит в отображаемые области;
//           Ложь - не входит.
//
Функция ИнтервалОтображается(Начало, Конец, ОтображаемыеИнтервалы) Экспорт
	
	Отображается = Ложь;
	
	Для Каждого Интервал Из ОтображаемыеИнтервалы Цикл
		
		Если (Конец >= Интервал.Начало И Конец <= Интервал.Конец)
			ИЛИ (Начало <= Интервал.Конец И Начало >= Интервал.Начало)
			ИЛИ (Начало <= Интервал.Начало) И (Конец >= Интервал.Конец) Тогда
			
			Отображается = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Отображается;
	
КонецФункции

// Опледеляет области табличного документа по временному интервалу.
//
// Параметры:
//  Начало - Дата - Начало временного интервала.
//  Конец - Дата - Конец временного интервала.
//  ОтображаемыеИнтервалы - Массив - Области отображаемые на календаре.
//  СекундВИнтервале - Число - Размер интервала в секундах.
//
// Возвращаемое значение:
//  Массив - Массив структур описывающие области табличного документа,
//           попавшие во временные ракмки.
//
Функция НомераЯчеекОбласти(Начало, Конец, ОтображаемыеИнтервалы, СекундВИнтервале) Экспорт
	
	ШагРазделителя = ?(ОтображаемыеИнтервалы.Количество() > 1, 1, 0);
	ОтступОтКрая = 1 + ШагРазделителя;
	ДатыОтображения = Новый Массив;
	
	СчДата = НачалоДня(Начало);
	Пока СчДата <= НачалоДня(Конец) Цикл
		
		ДатыОтображения.Добавить(СчДата);
		СчДата = КонецДня(СчДата) + 1;
		
	КонецЦикла;
	
	Области = Новый Массив;
	
	Для Каждого Интервал Из ОтображаемыеИнтервалы Цикл
		
		Если ДатыОтображения.Найти(Интервал.Дата) <> Неопределено Тогда
			
			Область = Новый Структура;
			Область.Вставить(
				"Первая",
				ОтступОтКрая + НомерЯчейкиПоДате(Макс(Начало, Интервал.Начало), Интервал.Начало, СекундВИнтервале));
			
			Область.Вставить(
				"Последняя",
				ОтступОтКрая + НомерЯчейкиПоДате(Мин(Конец, Интервал.Конец), Интервал.Начало, СекундВИнтервале, Истина));
			
			Области.Добавить(Область);
			
		КонецЕсли;
		
		ОтступОтКрая = ОтступОтКрая + ШагРазделителя + Интервал.ВсегоИнтервалов;
		
	КонецЦикла;
	
	Возврат Области;
	
КонецФункции

// Определение размера интервала на календаре в секунда
//
// Параметры:
//  Форма - УправляемаяФорма - Форма с календарем.
//
// Возвращаемое значение:
//  Число - Количество секунд в интервале.
//
Функция РазмерИнтервалаВСекундах(Форма) Экспорт
	
	Если Форма.РазмерСеткиРедактированияПланировщика
		= ПредопределенноеЗначение("Перечисление.РазмерСеткиРедактированияПланировщика.ПятьМинут") Тогда
		
		Возврат 300;
		
	Иначе
		
		Возврат Форма.РежимШкалыМинут * 300;
		
	КонецЕсли;
	
КонецФункции

// Определяет интервал отображения, в который попадает момент времени.
//
// Параметры:
//  Дата                  - Дата   - Дата интервал которой необходимо найти.
//  ОтображаемыеИнтервалы - Массив - Интервалы отображения.
// 
// Возвращаемое значение:
//  Неопределено, Структура - Интервал момента времени.
//
Функция ИнтервалОтображенияПоДате(Дата, ОтображаемыеИнтервалы) Экспорт
	
	Для Каждого Интервал Из ОтображаемыеИнтервалы Цикл
		
		Если НачалоДня(Дата) = Интервал.Дата Тогда
			
			Возврат Интервал;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

#Область РаботаСШаблонами

// Возвращает разбор расшифровки.
//
// Параметры:
//  Расшифровка - Строка - Расшифровка для разбора.
// 
// Возвращаемое значение:
//  Произвольный - Результат разбора.
//
Функция РазобратьРасшифровку(Расшифровка) Экспорт
	
	#Если ВебКлиент Тогда
		ВызватьИсключение НСтр("ru='Разбор json недоступно в вэб клиенте.'");
	#Иначе
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(Расшифровка);
		
		Возврат ПрочитатьJSON(ЧтениеJSON, Истина);
		
	#КонецЕсли
	
КонецФункции

// Расшифровка текущего интервала
//
// Параметры:
//  ДанныеРасшифровки - Массив - Данные расшифровки интервала.
// 
// Возвращаемое значение:
//  Строка - Расшифровка интервала.
//
Функция РасшифровкаТекущегоИнтервала(ДанныеРасшифровки) Экспорт
	
	// Экранируем символы
	ЭкранированнаяСтрока = СтрЗаменить(ДанныеРасшифровки[3], "\", "\\");
	ЭкранированнаяСтрока = СтрЗаменить(ЭкранированнаяСтрока, """", "\""");
	ЭкранированнаяСтрока = СтрЗаменить(ЭкранированнаяСтрока, Символы.Таб, "\t");
	ЭкранированнаяСтрока = СтрЗаменить(ЭкранированнаяСтрока, Символы.ПС, "\n");
	ЭкранированнаяСтрока = СтрЗаменить(ЭкранированнаяСтрока, Символы.ВК, "\r");
	
	Возврат стрШаблон(
		"{""type"":""CurrentPlan"",""index"":%1,""name"":""%2"",""obj"":%3,""note"":""%4""}",
		ДанныеРасшифровки[0],
		ДанныеРасшифровки[1],
		ДанныеРасшифровки[2],
		ЭкранированнаяСтрока
	);
	
КонецФункции

// Расшифровка примечания
//
// Параметры:
//  ДанныеРасшифровки - Массив - Данные расшифровки.
// 
// Возвращаемое значение:
//  Строка - Результат расшифровки.
//
Функция РасшифровкаПримечания(ДанныеРасшифровки) Экспорт
	
	Возврат стрШаблон("{""type"":""Note"",""parent"":%1}", ДанныеРасшифровки[0]);
	
КонецФункции

#КонецОбласти

// Представление интервала планирования на графике
//
// Параметры:
//  ТекущийОбъектЗаписиНаРемонт - ДанныеФормыСтруктура - Текущий объект в форме записи на ремонт
//  Интервал                    - ЭлементДанныхФормыКоллекция - Описание текущего интервала
// 
// Возвращаемое значение:
//  Строка
//
Функция ПредставлениеИнтервала(ТекущийОбъектЗаписиНаРемонт, Интервал) Экспорт
	
	Если ЭтоВидОбъектаПричинаОбращения(Интервал.ВидОбъектаПланирования) Тогда
		
		НайденныеЭлементыПричин = ТекущийОбъектЗаписиНаРемонт.ПричиныОбращения.НайтиСтроки(
			Новый Структура("ИдентификаторПричиныОбращения", Интервал.Идентификатор)
		);
		
		Если НайденныеЭлементыПричин.Количество() > 0 Тогда
			
			Возврат НайденныеЭлементыПричин[0].ПричинаОбращенияСодержание;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Строка(Интервал.Объект);
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ИтогЗначениеВМассивеСтрок(МассивСтрок, Колонка = "НормаВремени")
	
	Результат = 0;
	
	Для Каждого Строка Из МассивСтрок Цикл
		Результат = Результат + Строка[Колонка];
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция КартинкаПричиныОбращенияСГруппой()
	
	Возврат 5;
	
КонецФункции

Функция КартинкаПричиныОбращения()
	
	Возврат 1;
	
КонецФункции

Функция КартинкаАвтоработы()
	
	Возврат 3;
	
КонецФункции

Функция ПодготовитьМассивЭлементовДляСохраненияПорядка(Объект)
	
	Массив = Новый Массив;
	
	// ТипЭлемента = 1-причина, 2-авторабота, 3-всп авторабота
	
	Для Каждого Причина Из Объект.ПричиныОбращения Цикл
		//@skip-check unknown-method-property
		Массив.Добавить(Новый Структура("ИдентификаторСтроки, ОбъектПланирования, ТипЭлемента", Причина.ПолучитьИдентификатор(), Причина.ПричинаОбращения, 1));
	КонецЦикла;
	
	Для Каждого Авторабота Из Объект.Автоработы Цикл
		
		//@skip-check unknown-method-property
		СтруктураЭлементов = Новый Структура(
			"ИдентификаторСтроки, ОбъектПланирования, ИдентификаторПричиныОбращения",
			Авторабота.ПолучитьИдентификатор(),
			Авторабота.Авторабота,
			Авторабота.ИдентификаторПричиныОбращения
		);
		СтруктураЭлементов.Вставить("ТипЭлемента", 2);
		
		Массив.Добавить(СтруктураЭлементов);
		
	КонецЦикла;
	
	Для Каждого Авторабота Из Объект.ВспомогательныеАвтоработы Цикл
		//@skip-check unknown-method-property
		Массив.Добавить(Новый Структура("ИдентификаторСтроки, ОбъектПланирования, ТипЭлемента", Авторабота.ПолучитьИдентификатор(), Авторабота.Авторабота, 3));
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции

Функция НомерЯчейкиПоДате(Дата, НачалоОтображаемогоИнтервала, СекундВИнтервале, Конец = Ложь)
	
	Смещение = 1;
	РазницаСНачалом = (Дата - НачалоОтображаемогоИнтервала);
	
	Если Конец И РазницаСНачалом % СекундВИнтервале = 0 Тогда
		
		Смещение = Смещение - 1;
		
	КонецЕсли;
	
	Возврат Цел(РазницаСНачалом / СекундВИнтервале) + Смещение;
	
КонецФункции

Функция ЭтоВидОбъектаПричинаОбращения(ВидОбъектаПланирования)
	
	ВидОбъектаПланированияПричинаОбращения = ПредопределенноеЗначение(
		"Перечисление.ВидыОбъектовПланированияРесурсов.ПричинаОбращения"
	);
	Возврат ВидОбъектаПланирования = ВидОбъектаПланированияПричинаОбращения;
	
КонецФункции

#КонецОбласти

